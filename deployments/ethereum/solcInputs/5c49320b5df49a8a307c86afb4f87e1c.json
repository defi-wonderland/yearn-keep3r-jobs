{
  "language": "Solidity",
  "sources": {
    "solidity/contracts/for-test/BasicStealthJob.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../utils/Keep3rMeteredStealthJob.sol';\n\ncontract BasicStealthJob is Keep3rMeteredStealthJob {\n  uint256 public nonce;\n  mapping(uint256 => address) public dataset;\n\n  constructor(address _stealthRelayer) Governable(msg.sender) {\n    _setStealthRelayer(_stealthRelayer);\n  }\n\n  function work() external upkeepStealthy {}\n\n  function workUnsafe() external upkeep {}\n\n  function workHard(uint256 _howHard) external upkeepStealthy {\n    _workHard(_howHard);\n  }\n\n  function workUnsafe(uint256 _howHard) external upkeep {\n    _workHard(_howHard);\n  }\n\n  function workClean(uint256 _howHard, uint256 _cleanFreq) external upkeepStealthy {\n    _workClean(_howHard, _cleanFreq);\n  }\n\n  function workCleanUnsafe(uint256 _howHard, uint256 _cleanFreq) external upkeep {\n    _workClean(_howHard, _cleanFreq);\n  }\n\n  function _workHard(uint256 _howHard) internal {\n    for (uint256 _i = 0; _i < _howHard; _i++) {\n      nonce++;\n    }\n  }\n\n  function _workClean(uint256 _howHard, uint256 _cleanFreq) internal {\n    for (uint256 _i = 1; _i < _howHard; _i++) {\n      dataset[_i] = address(this);\n      if (_i % _cleanFreq == 0) {\n        delete dataset[_i];\n      }\n    }\n  }\n}\n"
    },
    "solidity/contracts/utils/Keep3rMeteredStealthJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Keep3rMeteredJob.sol';\nimport './Keep3rBondedJob.sol';\nimport './OnlyEOA.sol';\n\nimport '../../interfaces/utils/IKeep3rStealthJob.sol';\nimport '../../interfaces/external/IStealthRelayer.sol';\n\nabstract contract Keep3rMeteredStealthJob is IKeep3rStealthJob, Keep3rMeteredJob, Keep3rBondedJob, OnlyEOA {\n  /// @inheritdoc IKeep3rStealthJob\n  address public stealthRelayer;\n\n  // methods\n\n  /// @inheritdoc IKeep3rStealthJob\n  function setStealthRelayer(address _stealthRelayer) public onlyGovernor {\n    _setStealthRelayer(_stealthRelayer);\n  }\n\n  // modifiers\n\n  modifier onlyStealthRelayer() {\n    if (msg.sender != stealthRelayer) revert OnlyStealthRelayer();\n    _;\n  }\n\n  modifier upkeepStealthy() {\n    uint256 _initialGas = _getGasLeft();\n    if (msg.sender != stealthRelayer) revert OnlyStealthRelayer();\n    address _keeper = IStealthRelayer(stealthRelayer).caller();\n    _isValidKeeper(_keeper);\n\n    _;\n\n    uint256 _gasAfterWork = _getGasLeft();\n    uint256 _reward = (_calculateGas(_initialGas - _gasAfterWork + gasBonus) * gasMultiplier) / BASE;\n    uint256 _payment = IKeep3rHelper(keep3rHelper).quote(_reward);\n    IKeep3rV2(keep3r).bondedPayment(_keeper, _payment);\n    emit GasMetered(_initialGas, _gasAfterWork, gasBonus);\n  }\n\n  // internals\n\n  function _isValidKeeper(address _keeper) internal override(Keep3rBondedJob, Keep3rJob) {\n    if (onlyEOA) _validateEOA(_keeper);\n    super._isValidKeeper(_keeper);\n  }\n\n  function _setStealthRelayer(address _stealthRelayer) internal {\n    stealthRelayer = _stealthRelayer;\n    emit StealthRelayerSet(_stealthRelayer);\n  }\n\n  /// @notice Return the gas left and add 1/64 in order to match real gas left at first level of depth (EIP-150)\n  function _getGasLeft() internal view returns (uint256 _gasLeft) {\n    _gasLeft = (gasleft() * 64) / 63;\n  }\n}\n"
    },
    "solidity/contracts/utils/Keep3rMeteredJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Keep3rJob.sol';\nimport '../../interfaces/external/IKeep3rHelper.sol';\nimport '../../interfaces/utils/IKeep3rMeteredJob.sol';\n\nabstract contract Keep3rMeteredJob is IKeep3rMeteredJob, Keep3rJob {\n  /// @inheritdoc IKeep3rMeteredJob\n  address public keep3rHelper = 0xD36Ac9Ff5562abb541F51345f340FB650547a661;\n  /// @inheritdoc IKeep3rMeteredJob\n  uint256 public gasBonus = 86_000;\n  /// @inheritdoc IKeep3rMeteredJob\n  uint256 public gasMultiplier = 12_000;\n  /// @inheritdoc IKeep3rMeteredJob\n  uint32 public constant BASE = 10_000;\n  /// @inheritdoc IKeep3rMeteredJob\n  uint256 public maxMultiplier = 15_000;\n\n  // setters\n\n  /// @inheritdoc IKeep3rMeteredJob\n  function setKeep3rHelper(address _keep3rHelper) public onlyGovernor {\n    _setKeep3rHelper(_keep3rHelper);\n  }\n\n  /// @inheritdoc IKeep3rMeteredJob\n  function setGasBonus(uint256 _gasBonus) external onlyGovernor {\n    _setGasBonus(_gasBonus);\n  }\n\n  /// @inheritdoc IKeep3rMeteredJob\n  function setMaxMultiplier(uint256 _maxMultiplier) external onlyGovernor {\n    _setMaxMultiplier(_maxMultiplier);\n  }\n\n  /// @inheritdoc IKeep3rMeteredJob\n  function setGasMultiplier(uint256 _gasMultiplier) external onlyGovernor {\n    _setGasMultiplier(_gasMultiplier);\n  }\n\n  // modifiers\n\n  modifier upkeepMetered() {\n    uint256 _initialGas = gasleft();\n    _isValidKeeper(msg.sender);\n    _;\n    uint256 _gasAfterWork = gasleft();\n    uint256 _reward = (_calculateGas(_initialGas - _gasAfterWork + gasBonus) * gasMultiplier) / BASE;\n    uint256 _payment = IKeep3rHelper(keep3rHelper).quote(_reward);\n    IKeep3rV2(keep3r).bondedPayment(msg.sender, _payment);\n    emit GasMetered(_initialGas, _gasAfterWork, gasBonus);\n  }\n\n  // internals\n\n  function _setKeep3rHelper(address _keep3rHelper) internal {\n    keep3rHelper = _keep3rHelper;\n    emit Keep3rHelperSet(_keep3rHelper);\n  }\n\n  function _setGasBonus(uint256 _gasBonus) internal {\n    gasBonus = _gasBonus;\n    emit GasBonusSet(gasBonus);\n  }\n\n  function _setMaxMultiplier(uint256 _maxMultiplier) internal {\n    maxMultiplier = _maxMultiplier;\n    emit MaxMultiplierSet(maxMultiplier);\n  }\n\n  function _setGasMultiplier(uint256 _gasMultiplier) internal {\n    if (_gasMultiplier > maxMultiplier) revert MaxMultiplier();\n    gasMultiplier = _gasMultiplier;\n    emit GasMultiplierSet(gasMultiplier);\n  }\n\n  function _calculateGas(uint256 _gasUsed) internal view returns (uint256 _resultingGas) {\n    _resultingGas = block.basefee * _gasUsed;\n  }\n\n  function _calculateCredits(uint256 _gasUsed) internal view returns (uint256 _credits) {\n    return IKeep3rHelper(keep3rHelper).getRewardAmount(_calculateGas(_gasUsed));\n  }\n}\n"
    },
    "solidity/contracts/utils/Keep3rBondedJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Keep3rJob.sol';\nimport '../../interfaces/utils/IKeep3rBondedJob.sol';\n\nabstract contract Keep3rBondedJob is IKeep3rBondedJob, Keep3rJob {\n  /// @inheritdoc IKeep3rBondedJob\n  address public requiredBond = 0x1cEB5cB57C4D4E2b2433641b95Dd330A33185A44;\n  /// @inheritdoc IKeep3rBondedJob\n  uint256 public requiredMinBond = 50 ether;\n  /// @inheritdoc IKeep3rBondedJob\n  uint256 public requiredEarnings;\n  /// @inheritdoc IKeep3rBondedJob\n  uint256 public requiredAge;\n\n  // methods\n\n  /// @inheritdoc IKeep3rBondedJob\n  function setKeep3rRequirements(\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) public onlyGovernor {\n    _setKeep3rRequirements(_bond, _minBond, _earned, _age);\n  }\n\n  // internals\n\n  function _setKeep3rRequirements(\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) internal {\n    requiredBond = _bond;\n    requiredMinBond = _minBond;\n    requiredEarnings = _earned;\n    requiredAge = _age;\n    emit Keep3rRequirementsSet(_bond, _minBond, _earned, _age);\n  }\n\n  function _isValidKeeper(address _keeper) internal virtual override {\n    if (!IKeep3rV2(keep3r).isBondedKeeper(_keeper, requiredBond, requiredMinBond, requiredEarnings, requiredAge)) revert KeeperNotValid();\n  }\n}\n"
    },
    "solidity/contracts/utils/OnlyEOA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../../interfaces/utils/IOnlyEOA.sol';\nimport './Governable.sol';\n\nabstract contract OnlyEOA is IOnlyEOA, Governable {\n  /// @inheritdoc IOnlyEOA\n  bool public onlyEOA;\n\n  // methods\n\n  /// @inheritdoc IOnlyEOA\n  function setOnlyEOA(bool _onlyEOA) external onlyGovernor {\n    _setOnlyEOA(_onlyEOA);\n  }\n\n  // internals\n\n  function _setOnlyEOA(bool _onlyEOA) internal {\n    onlyEOA = _onlyEOA;\n    emit OnlyEOASet(_onlyEOA);\n  }\n\n  function _validateEOA(address _caller) internal view {\n    // solhint-disable-next-line avoid-tx-origin\n    if (_caller != tx.origin) revert OnlyEOA();\n  }\n}\n"
    },
    "solidity/interfaces/utils/IKeep3rStealthJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rJob.sol';\n\ninterface IKeep3rStealthJob is IKeep3rJob {\n  // events\n\n  /// @notice Emitted when a new StealthRelayer contract is set\n  /// @param _stealthRelayer Address of the new StealthRelayer contract\n  event StealthRelayerSet(address _stealthRelayer);\n\n  // errors\n\n  /// @notice Throws when a OnlyStealthRelayer function is called from an unknown address\n  error OnlyStealthRelayer();\n\n  // views\n\n  /// @return _stealthRelayer Address of the StealthRelayer contract\n  function stealthRelayer() external view returns (address _stealthRelayer);\n\n  // methods\n\n  /// @notice Allows governor to set a new StealthRelayer contract\n  /// @param _stealthRelayer Address of the new StealthRelayer contract\n  function setStealthRelayer(address _stealthRelayer) external;\n}\n"
    },
    "solidity/interfaces/external/IStealthRelayer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\nimport './IStealthTx.sol';\n\ninterface IStealthRelayer is IStealthTx {\n  function caller() external view returns (address _caller);\n\n  function forceBlockProtection() external view returns (bool _forceBlockProtection);\n\n  function jobs() external view returns (address[] memory _jobsList);\n\n  function setForceBlockProtection(bool _forceBlockProtection) external;\n\n  function addJobs(address[] calldata _jobsList) external;\n\n  function addJob(address _job) external;\n\n  function removeJobs(address[] calldata _jobsList) external;\n\n  function removeJob(address _job) external;\n\n  function execute(\n    address _address,\n    bytes memory _callData,\n    bytes32 _stealthHash,\n    uint256 _blockNumber\n  ) external payable returns (bytes memory _returnData);\n\n  function executeAndPay(\n    address _address,\n    bytes memory _callData,\n    bytes32 _stealthHash,\n    uint256 _blockNumber,\n    uint256 _payment\n  ) external payable returns (bytes memory _returnData);\n\n  function executeWithoutBlockProtection(\n    address _address,\n    bytes memory _callData,\n    bytes32 _stealthHash\n  ) external payable returns (bytes memory _returnData);\n\n  function executeWithoutBlockProtectionAndPay(\n    address _job,\n    bytes memory _callData,\n    bytes32 _stealthHash,\n    uint256 _payment\n  ) external payable returns (bytes memory _returnData);\n}\n"
    },
    "solidity/contracts/utils/Keep3rJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Governable.sol';\nimport '../../interfaces/utils/IKeep3rJob.sol';\nimport '../../interfaces/external/IKeep3rV2.sol';\n\nabstract contract Keep3rJob is IKeep3rJob, Governable {\n  /// @inheritdoc IKeep3rJob\n  address public keep3r = 0xeb02addCfD8B773A5FFA6B9d1FE99c566f8c44CC;\n\n  // methods\n\n  /// @inheritdoc IKeep3rJob\n  function setKeep3r(address _keep3r) public onlyGovernor {\n    _setKeep3r(_keep3r);\n  }\n\n  // modifiers\n\n  modifier upkeep() {\n    _isValidKeeper(msg.sender);\n    _;\n    IKeep3rV2(keep3r).worked(msg.sender);\n  }\n\n  // internals\n\n  function _setKeep3r(address _keep3r) internal {\n    keep3r = _keep3r;\n    emit Keep3rSet(_keep3r);\n  }\n\n  function _isValidKeeper(address _keeper) internal virtual {\n    if (!IKeep3rV2(keep3r).isKeeper(_keeper)) revert KeeperNotValid();\n  }\n}\n"
    },
    "solidity/interfaces/external/IKeep3rHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/// @title Keep3rHelper contract\n/// @notice Contains all the helper functions used throughout the different files.\ninterface IKeep3rHelper {\n  // Errors\n\n  /// @notice Throws when none of the tokens in the liquidity pair is KP3R\n  error LiquidityPairInvalid();\n\n  // Variables\n\n  /// @notice Address of KP3R token\n  /// @return _kp3r Address of KP3R token\n  // solhint-disable func-name-mixedcase\n  function KP3R() external view returns (address _kp3r);\n\n  /// @notice Address of KP3R-WETH pool to use as oracle\n  /// @return _kp3rWeth Address of KP3R-WETH pool to use as oracle\n  function KP3R_WETH_POOL() external view returns (address _kp3rWeth);\n\n  /// @notice The minimum multiplier used to calculate the amount of gas paid to the Keeper for the gas used to perform a job\n  ///         For example: if the quoted gas used is 1000, then the minimum amount to be paid will be 1000 * MIN / BOOST_BASE\n  /// @return _multiplier The MIN multiplier\n  function MIN() external view returns (uint256 _multiplier);\n\n  /// @notice The maximum multiplier used to calculate the amount of gas paid to the Keeper for the gas used to perform a job\n  ///         For example: if the quoted gas used is 1000, then the maximum amount to be paid will be 1000 * MAX / BOOST_BASE\n  /// @return _multiplier The MAX multiplier\n  function MAX() external view returns (uint256 _multiplier);\n\n  /// @notice The boost base used to calculate the boost rewards for the keeper\n  /// @return _base The boost base number\n  function BOOST_BASE() external view returns (uint256 _base);\n\n  /// @notice The targeted amount of bonded KP3Rs to max-up reward multiplier\n  ///         For example: if the amount of KP3R the keeper has bonded is TARGETBOND or more, then the keeper will get\n  ///                      the maximum boost possible in his rewards, if it's less, the reward boost will be proportional\n  /// @return _target The amount of KP3R that comforms the TARGETBOND\n  function TARGETBOND() external view returns (uint256 _target);\n\n  // Methods\n  // solhint-enable func-name-mixedcase\n\n  /// @notice Calculates the amount of KP3R that corresponds to the ETH passed into the function\n  /// @dev This function allows us to calculate how much KP3R we should pay to a keeper for things expressed in ETH, like gas\n  /// @param _eth The amount of ETH\n  /// @return _amountOut The amount of KP3R\n  function quote(uint256 _eth) external view returns (uint256 _amountOut);\n\n  /// @notice Returns the amount of KP3R the keeper has bonded\n  /// @param _keeper The address of the keeper to check\n  /// @return _amountBonded The amount of KP3R the keeper has bonded\n  function bonds(address _keeper) external view returns (uint256 _amountBonded);\n\n  /// @notice Calculates the reward (in KP3R) that corresponds to a keeper for using gas\n  /// @param _keeper The address of the keeper to check\n  /// @param _gasUsed The amount of gas used that will be rewarded\n  /// @return _kp3r The amount of KP3R that should be awarded to the keeper\n  function getRewardAmountFor(address _keeper, uint256 _gasUsed) external view returns (uint256 _kp3r);\n\n  /// @notice Calculates the boost in the reward given to a keeper based on the amount of KP3R that keeper has bonded\n  /// @param _bonds The amount of KP3R tokens bonded by the keeper\n  /// @return _rewardBoost The reward boost that corresponds to the keeper\n  function getRewardBoostFor(uint256 _bonds) external view returns (uint256 _rewardBoost);\n\n  /// @notice Calculates the reward (in KP3R) that corresponds to tx.origin for using gas\n  /// @param _gasUsed The amount of gas used that will be rewarded\n  /// @return _amount The amount of KP3R that should be awarded to tx.origin\n  function getRewardAmount(uint256 _gasUsed) external view returns (uint256 _amount);\n\n  /// @notice Given a pool address, returns the underlying tokens of the pair\n  /// @param _pool Address of the correspondant pool\n  /// @return _token0 Address of the first token of the pair\n  /// @return _token1 Address of the second token of the pair\n  function getPoolTokens(address _pool) external view returns (address _token0, address _token1);\n\n  /// @notice Defines the order of the tokens in the pair for twap calculations\n  /// @param _pool Address of the correspondant pool\n  /// @return _isKP3RToken0 Boolean indicating the order of the tokens in the pair\n  function isKP3RToken0(address _pool) external view returns (bool _isKP3RToken0);\n\n  /// @notice Given an array of secondsAgo, returns UniswapV3 pool cumulatives at that moment\n  /// @param _pool Address of the pool to observe\n  /// @param _secondsAgo Array with time references to observe\n  /// @return _tickCumulative1 Cummulative sum of ticks until first time reference\n  /// @return _tickCumulative2 Cummulative sum of ticks until second time reference\n  /// @return _success Boolean indicating if the observe call was succesfull\n  function observe(address _pool, uint32[] memory _secondsAgo)\n    external\n    view\n    returns (\n      int56 _tickCumulative1,\n      int56 _tickCumulative2,\n      bool _success\n    );\n\n  /// @notice Given a tick and a liquidity amount, calculates the underlying KP3R tokens\n  /// @param _liquidityAmount Amount of liquidity to be converted\n  /// @param _tickDifference Tick value used to calculate the quote\n  /// @param _timeInterval Time value used to calculate the quote\n  /// @return _kp3rAmount Amount of KP3R tokens underlying on the given liquidity\n  function getKP3RsAtTick(\n    uint256 _liquidityAmount,\n    int56 _tickDifference,\n    uint256 _timeInterval\n  ) external pure returns (uint256 _kp3rAmount);\n\n  /// @notice Given a tick and a token amount, calculates the output in correspondant token\n  /// @param _baseAmount Amount of token to be converted\n  /// @param _tickDifference Tick value used to calculate the quote\n  /// @param _timeInterval Time value used to calculate the quote\n  /// @return _quoteAmount Amount of credits deserved for the baseAmount at the tick value\n  function getQuoteAtTick(\n    uint128 _baseAmount,\n    int56 _tickDifference,\n    uint256 _timeInterval\n  ) external pure returns (uint256 _quoteAmount);\n}\n"
    },
    "solidity/interfaces/utils/IKeep3rMeteredJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rJob.sol';\n\ninterface IKeep3rMeteredJob is IKeep3rJob {\n  // events\n\n  /// @notice Emitted when a new Keep3rHelper contract is set\n  /// @param _keep3rHelper Address of the new Keep3rHelper contract\n  event Keep3rHelperSet(address _keep3rHelper);\n\n  /// @notice Emitted when a new gas bonus amount is set\n  /// @param _gasBonus Amount of gas to add to cover unaccounted gas\n  event GasBonusSet(uint256 _gasBonus);\n\n  /// @notice Emitted when a new gas bonus multiplier is set\n  /// @param _gasMultiplier Multiplier that boosts gas record to calculate the keeper reward\n  event GasMultiplierSet(uint256 _gasMultiplier);\n\n  /// @notice Emitted when a new gas bonus multiplier maximum is set\n  /// @param _maxMultiplier Maximum acceptable gasMultiplier to be set\n  event MaxMultiplierSet(uint256 _maxMultiplier);\n\n  /// @notice Emitted when a metered job is worked\n  /// @param _initialGas First gas record registered\n  /// @param _gasAfterWork Gas record registered after work\n  /// @param _bonus Fixed amount of gas added to the accountance\n  event GasMetered(uint256 _initialGas, uint256 _gasAfterWork, uint256 _bonus);\n\n  // errors\n  error MaxMultiplier();\n\n  // views\n\n  /// @return _keep3rHelper Address of the Keep3rHelper contract\n  function keep3rHelper() external view returns (address _keep3rHelper);\n\n  /// @return _gasBonus Amount of gas to add to cover unaccounted gas\n  function gasBonus() external view returns (uint256 _gasBonus);\n\n  /// @return _gasMultiplier Multiplier that boosts gas record to calculate the keeper reward\n  function gasMultiplier() external view returns (uint256 _gasMultiplier);\n\n  /// @return _maxMultiplier Maximum acceptable gasMultiplier to be set\n  function maxMultiplier() external view returns (uint256 _maxMultiplier);\n\n  // solhint-disable-next-line func-name-mixedcase, var-name-mixedcase\n  function BASE() external view returns (uint32 _BASE);\n\n  // methods\n\n  /// @notice Allows governor to set a new Keep3rHelper contract\n  /// @param _keep3rHelper Address of the new Keep3rHelper contract\n  function setKeep3rHelper(address _keep3rHelper) external;\n\n  /// @notice Allows governor to set a new gas bonus amount\n  /// @param _gasBonus New amount of gas to add to cover unaccounted gas\n  function setGasBonus(uint256 _gasBonus) external;\n\n  /// @notice Allows governor to set a new gas multiplier\n  /// @param _gasMultiplier New multiplier that boosts gas record to calculate the keeper reward\n  function setGasMultiplier(uint256 _gasMultiplier) external;\n\n  /// @notice Allows governor to set a new gas multiplier maximum\n  /// @param _maxMultiplier New maximum acceptable gasMultiplier to be set\n  function setMaxMultiplier(uint256 _maxMultiplier) external;\n}\n"
    },
    "solidity/contracts/utils/Governable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../../interfaces/utils/IGovernable.sol';\n\nabstract contract Governable is IGovernable {\n  /// @inheritdoc IGovernable\n  address public governor;\n  /// @inheritdoc IGovernable\n  address public pendingGovernor;\n\n  constructor(address _governor) {\n    if (_governor == address(0)) revert ZeroAddress();\n    governor = _governor;\n  }\n\n  // methods\n\n  /// @inheritdoc IGovernable\n  function setPendingGovernor(address _pendingGovernor) external onlyGovernor {\n    _setPendingGovernor(_pendingGovernor);\n  }\n\n  /// @inheritdoc IGovernable\n  function acceptPendingGovernor() external onlyPendingGovernor {\n    _acceptPendingGovernor();\n  }\n\n  // modifiers\n\n  modifier onlyGovernor() {\n    if (msg.sender != governor) revert OnlyGovernor();\n    _;\n  }\n\n  modifier onlyPendingGovernor() {\n    if (msg.sender != pendingGovernor) revert OnlyPendingGovernor();\n    _;\n  }\n\n  // internals\n\n  function _setPendingGovernor(address _pendingGovernor) internal {\n    if (_pendingGovernor == address(0)) revert ZeroAddress();\n    pendingGovernor = _pendingGovernor;\n    emit PendingGovernorSet(governor, pendingGovernor);\n  }\n\n  function _acceptPendingGovernor() internal {\n    governor = pendingGovernor;\n    pendingGovernor = address(0);\n    emit PendingGovernorAccepted(governor);\n  }\n}\n"
    },
    "solidity/interfaces/utils/IKeep3rJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IGovernable.sol';\n\ninterface IKeep3rJob is IGovernable {\n  // events\n\n  /// @notice Emitted when a new Keep3r contract is set\n  /// @param _keep3r Address of the new Keep3r contract\n  event Keep3rSet(address _keep3r);\n\n  // errors\n\n  /// @notice Throws when a keeper fails the validation\n  error KeeperNotValid();\n\n  // views\n\n  /// @return _keep3r Address of the Keep3r contract\n  function keep3r() external view returns (address _keep3r);\n\n  // methods\n\n  /// @notice Allows governor to set a new Keep3r contract\n  /// @param _keep3r Address of the new Keep3r contract\n  function setKeep3r(address _keep3r) external;\n}\n"
    },
    "solidity/interfaces/external/IKeep3rV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IKeep3rV2 {\n  /// @notice Stores the tick information of the different liquidity pairs\n  struct TickCache {\n    int56 current; // Tracks the current tick\n    int56 difference; // Stores the difference between the current tick and the last tick\n    uint256 period; // Stores the period at which the last observation was made\n  }\n\n  // Events\n\n  /// @notice Emitted when the Keep3rHelper address is changed\n  /// @param _keep3rHelper The address of Keep3rHelper's contract\n  event Keep3rHelperChange(address _keep3rHelper);\n\n  /// @notice Emitted when the Keep3rV1 address is changed\n  /// @param _keep3rV1 The address of Keep3rV1's contract\n  event Keep3rV1Change(address _keep3rV1);\n\n  /// @notice Emitted when the Keep3rV1Proxy address is changed\n  /// @param _keep3rV1Proxy The address of Keep3rV1Proxy's contract\n  event Keep3rV1ProxyChange(address _keep3rV1Proxy);\n\n  /// @notice Emitted when the KP3R-WETH pool address is changed\n  /// @param _kp3rWethPool The address of the KP3R-WETH pool\n  event Kp3rWethPoolChange(address _kp3rWethPool);\n\n  /// @notice Emitted when bondTime is changed\n  /// @param _bondTime The new bondTime\n  event BondTimeChange(uint256 _bondTime);\n\n  /// @notice Emitted when _liquidityMinimum is changed\n  /// @param _liquidityMinimum The new _liquidityMinimum\n  event LiquidityMinimumChange(uint256 _liquidityMinimum);\n\n  /// @notice Emitted when _unbondTime is changed\n  /// @param _unbondTime The new _unbondTime\n  event UnbondTimeChange(uint256 _unbondTime);\n\n  /// @notice Emitted when _rewardPeriodTime is changed\n  /// @param _rewardPeriodTime The new _rewardPeriodTime\n  event RewardPeriodTimeChange(uint256 _rewardPeriodTime);\n\n  /// @notice Emitted when the inflationPeriod is changed\n  /// @param _inflationPeriod The new inflationPeriod\n  event InflationPeriodChange(uint256 _inflationPeriod);\n\n  /// @notice Emitted when the fee is changed\n  /// @param _fee The new token credits fee\n  event FeeChange(uint256 _fee);\n\n  /// @notice Emitted when a slasher is added\n  /// @param _slasher Address of the added slasher\n  event SlasherAdded(address _slasher);\n\n  /// @notice Emitted when a slasher is removed\n  /// @param _slasher Address of the removed slasher\n  event SlasherRemoved(address _slasher);\n\n  /// @notice Emitted when a disputer is added\n  /// @param _disputer Address of the added disputer\n  event DisputerAdded(address _disputer);\n\n  /// @notice Emitted when a disputer is removed\n  /// @param _disputer Address of the removed disputer\n  event DisputerRemoved(address _disputer);\n\n  /// @notice Emitted when the bonding process of a new keeper begins\n  /// @param _keeper The caller of Keep3rKeeperFundable#bond function\n  /// @param _bonding The asset the keeper has bonded\n  /// @param _amount The amount the keeper has bonded\n  event Bonding(address indexed _keeper, address indexed _bonding, uint256 _amount);\n\n  /// @notice Emitted when a keeper or job begins the unbonding process to withdraw the funds\n  /// @param _keeperOrJob The keeper or job that began the unbonding process\n  /// @param _unbonding The liquidity pair or asset being unbonded\n  /// @param _amount The amount being unbonded\n  event Unbonding(address indexed _keeperOrJob, address indexed _unbonding, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperFundable#activate is called\n  /// @param _keeper The keeper that has been activated\n  /// @param _bond The asset the keeper has bonded\n  /// @param _amount The amount of the asset the keeper has bonded\n  event Activation(address indexed _keeper, address indexed _bond, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperFundable#withdraw is called\n  /// @param _keeper The caller of Keep3rKeeperFundable#withdraw function\n  /// @param _bond The asset to withdraw from the bonding pool\n  /// @param _amount The amount of funds withdrawn\n  event Withdrawal(address indexed _keeper, address indexed _bond, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperDisputable#slash is called\n  /// @param _keeper The slashed keeper\n  /// @param _slasher The user that called Keep3rKeeperDisputable#slash\n  /// @param _amount The amount of credits slashed from the keeper\n  event KeeperSlash(address indexed _keeper, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when Keep3rKeeperDisputable#revoke is called\n  /// @param _keeper The revoked keeper\n  /// @param _slasher The user that called Keep3rKeeperDisputable#revoke\n  event KeeperRevoke(address indexed _keeper, address indexed _slasher);\n\n  /// @notice Emitted when Keep3rJobFundableCredits#addTokenCreditsToJob is called\n  /// @param _job The address of the job being credited\n  /// @param _token The address of the token being provided\n  /// @param _provider The user that calls the function\n  /// @param _amount The amount of credit being added to the job\n  event TokenCreditAddition(address indexed _job, address indexed _token, address indexed _provider, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableCredits#withdrawTokenCreditsFromJob is called\n  /// @param _job The address of the job from which the credits are withdrawn\n  /// @param _token The credit being withdrawn from the job\n  /// @param _receiver The user that receives the tokens\n  /// @param _amount The amount of credit withdrawn\n  event TokenCreditWithdrawal(address indexed _job, address indexed _token, address indexed _receiver, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#approveLiquidity function is called\n  /// @param _liquidity The address of the liquidity pair being approved\n  event LiquidityApproval(address _liquidity);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#revokeLiquidity function is called\n  /// @param _liquidity The address of the liquidity pair being revoked\n  event LiquidityRevocation(address _liquidity);\n\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#addLiquidityToJob function is called\n  /// @param _job The address of the job to which liquidity will be added\n  /// @param _liquidity The address of the liquidity being added\n  /// @param _provider The user that calls the function\n  /// @param _amount The amount of liquidity being added\n  event LiquidityAddition(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _amount);\n\n  /// @notice Emitted when IKeep3rJobFundableLiquidity#withdrawLiquidityFromJob function is called\n  /// @param _job The address of the job of which liquidity will be withdrawn from\n  /// @param _liquidity The address of the liquidity being withdrawn\n  /// @param _receiver The receiver of the liquidity tokens\n  /// @param _amount The amount of liquidity being withdrawn from the job\n  event LiquidityWithdrawal(address indexed _job, address indexed _liquidity, address indexed _receiver, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#addLiquidityToJob function is called\n  /// @param _job The address of the job whose credits will be updated\n  /// @param _rewardedAt The time at which the job was last rewarded\n  /// @param _currentCredits The current credits of the job\n  /// @param _periodCredits The credits of the job for the current period\n  event LiquidityCreditsReward(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits, uint256 _periodCredits);\n\n  /// @notice Emitted when Keep3rJobFundableLiquidity#forceLiquidityCreditsToJob function is called\n  /// @param _job The address of the job whose credits will be updated\n  /// @param _rewardedAt The time at which the job was last rewarded\n  /// @param _currentCredits The current credits of the job\n  event LiquidityCreditsForced(address indexed _job, uint256 _rewardedAt, uint256 _currentCredits);\n\n  /// @notice Emitted when Keep3rJobManager#addJob is called\n  /// @param _job The address of the job to add\n  /// @param _jobOwner The job's owner\n  event JobAddition(address indexed _job, address indexed _jobOwner);\n\n  /// @notice Emitted when a keeper is validated before a job\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of keeper validation\n  event KeeperValidation(uint256 _gasLeft);\n\n  /// @notice Emitted when a keeper works a job\n  /// @param _credit The address of the asset in which the keeper is paid\n  /// @param _job The address of the job the keeper has worked\n  /// @param _keeper The address of the keeper that has worked the job\n  /// @param _amount The amount that has been paid out to the keeper in exchange for working the job\n  /// @param _gasLeft The amount of gas that the transaction has left at the moment of payment\n  event KeeperWork(address indexed _credit, address indexed _job, address indexed _keeper, uint256 _amount, uint256 _gasLeft);\n\n  /// @notice Emitted when Keep3rJobOwnership#changeJobOwnership is called\n  /// @param _job The address of the job proposed to have a change of owner\n  /// @param _owner The current owner of the job\n  /// @param _pendingOwner The new address proposed to be the owner of the job\n  event JobOwnershipChange(address indexed _job, address indexed _owner, address indexed _pendingOwner);\n\n  /// @notice Emitted when Keep3rJobOwnership#JobOwnershipAssent is called\n  /// @param _job The address of the job which the proposed owner will now own\n  /// @param _previousOwner The previous owner of the job\n  /// @param _newOwner The newowner of the job\n  event JobOwnershipAssent(address indexed _job, address indexed _previousOwner, address indexed _newOwner);\n\n  /// @notice Emitted when Keep3rJobMigration#migrateJob function is called\n  /// @param _fromJob The address of the job that requests to migrate\n  /// @param _toJob The address at which the job requests to migrate\n  event JobMigrationRequested(address indexed _fromJob, address _toJob);\n\n  /// @notice Emitted when Keep3rJobMigration#acceptJobMigration function is called\n  /// @param _fromJob The address of the job that requested to migrate\n  /// @param _toJob The address at which the job had requested to migrate\n  event JobMigrationSuccessful(address _fromJob, address indexed _toJob);\n\n  /// @notice Emitted when Keep3rJobDisputable#slashTokenFromJob is called\n  /// @param _job The address of the job from which the token will be slashed\n  /// @param _token The address of the token being slashed\n  /// @param _slasher The user that slashes the token\n  /// @param _amount The amount of the token being slashed\n  event JobSlashToken(address indexed _job, address _token, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when Keep3rJobDisputable#slashLiquidityFromJob is called\n  /// @param _job The address of the job from which the liquidity will be slashed\n  /// @param _liquidity The address of the liquidity being slashed\n  /// @param _slasher The user that slashes the liquidity\n  /// @param _amount The amount of the liquidity being slashed\n  event JobSlashLiquidity(address indexed _job, address _liquidity, address indexed _slasher, uint256 _amount);\n\n  /// @notice Emitted when a keeper or a job is disputed\n  /// @param _jobOrKeeper The address of the disputed keeper/job\n  /// @param _disputer The user that called the function and disputed the keeper\n  event Dispute(address indexed _jobOrKeeper, address indexed _disputer);\n\n  /// @notice Emitted when a dispute is resolved\n  /// @param _jobOrKeeper The address of the disputed keeper/job\n  /// @param _resolver The user that called the function and resolved the dispute\n  event Resolve(address indexed _jobOrKeeper, address indexed _resolver);\n\n  // Errors\n\n  /// @notice Throws if the reward period is less than the minimum reward period time\n  error MinRewardPeriod();\n\n  /// @notice Throws if either a job or a keeper is disputed\n  error Disputed();\n\n  /// @notice Throws if there are no bonded assets\n  error BondsUnexistent();\n\n  /// @notice Throws if the time required to bond an asset has not passed yet\n  error BondsLocked();\n\n  /// @notice Throws if there are no bonds to withdraw\n  error UnbondsUnexistent();\n\n  /// @notice Throws if the time required to withdraw the bonds has not passed yet\n  error UnbondsLocked();\n\n  /// @notice Throws if the address is already a registered slasher\n  error SlasherExistent();\n\n  /// @notice Throws if caller is not a registered slasher\n  error SlasherUnexistent();\n\n  /// @notice Throws if the address is already a registered disputer\n  error DisputerExistent();\n\n  /// @notice Throws if caller is not a registered disputer\n  error DisputerUnexistent();\n\n  /// @notice Throws if the msg.sender is not a slasher or is not a part of governance\n  error OnlySlasher();\n\n  /// @notice Throws if the msg.sender is not a disputer or is not a part of governance\n  error OnlyDisputer();\n\n  /// @notice Throws when an address is passed as a job, but that address is not a job\n  error JobUnavailable();\n\n  /// @notice Throws when an action that requires an undisputed job is applied on a disputed job\n  error JobDisputed();\n\n  /// @notice Throws when the address that is trying to register as a job is already a job\n  error AlreadyAJob();\n\n  /// @notice Throws when the token is KP3R, as it should not be used for direct token payments\n  error TokenUnallowed();\n\n  /// @notice Throws when the token withdraw cooldown has not yet passed\n  error JobTokenCreditsLocked();\n\n  /// @notice Throws when the user tries to withdraw more tokens than it has\n  error InsufficientJobTokenCredits();\n\n  /// @notice Throws when trying to add a job that has already been added\n  error JobAlreadyAdded();\n\n  /// @notice Throws when the address that is trying to register as a keeper is already a keeper\n  error AlreadyAKeeper();\n\n  /// @notice Throws when the liquidity being approved has already been approved\n  error LiquidityPairApproved();\n\n  /// @notice Throws when the liquidity being removed has not been approved\n  error LiquidityPairUnexistent();\n\n  /// @notice Throws when trying to add liquidity to an unapproved pool\n  error LiquidityPairUnapproved();\n\n  /// @notice Throws when the job doesn't have the requested liquidity\n  error JobLiquidityUnexistent();\n\n  /// @notice Throws when trying to remove more liquidity than the job has\n  error JobLiquidityInsufficient();\n\n  /// @notice Throws when trying to add less liquidity than the minimum liquidity required\n  error JobLiquidityLessThanMin();\n\n  /// @notice Throws if a variable is assigned to the zero address\n  error ZeroAddress();\n\n  /// @notice Throws if the address claiming to be a job is not in the list of approved jobs\n  error JobUnapproved();\n\n  /// @notice Throws if the amount of funds in the job is less than the payment that must be paid to the keeper that works that job\n  error InsufficientFunds();\n\n  /// @notice Throws when the caller of the function is not the job owner\n  error OnlyJobOwner();\n\n  /// @notice Throws when the caller of the function is not the pending job owner\n  error OnlyPendingJobOwner();\n\n  /// @notice Throws when the address of the job that requests to migrate wants to migrate to its same address\n  error JobMigrationImpossible();\n\n  /// @notice Throws when the _toJob address differs from the address being tracked in the pendingJobMigrations mapping\n  error JobMigrationUnavailable();\n\n  /// @notice Throws when cooldown between migrations has not yet passed\n  error JobMigrationLocked();\n\n  /// @notice Throws when the token trying to be slashed doesn't exist\n  error JobTokenUnexistent();\n\n  /// @notice Throws when someone tries to slash more tokens than the job has\n  error JobTokenInsufficient();\n\n  /// @notice Throws when a job or keeper is already disputed\n  error AlreadyDisputed();\n\n  /// @notice Throws when a job or keeper is not disputed and someone tries to resolve the dispute\n  error NotDisputed();\n\n  // Variables\n\n  /// @notice Address of Keep3rHelper's contract\n  /// @return _keep3rHelper The address of Keep3rHelper's contract\n  function keep3rHelper() external view returns (address _keep3rHelper);\n\n  /// @notice Address of Keep3rV1's contract\n  /// @return _keep3rV1 The address of Keep3rV1's contract\n  function keep3rV1() external view returns (address _keep3rV1);\n\n  /// @notice Address of Keep3rV1Proxy's contract\n  /// @return _keep3rV1Proxy The address of Keep3rV1Proxy's contract\n  function keep3rV1Proxy() external view returns (address _keep3rV1Proxy);\n\n  /// @notice Address of the KP3R-WETH pool\n  /// @return _kp3rWethPool The address of KP3R-WETH pool\n  function kp3rWethPool() external view returns (address _kp3rWethPool);\n\n  /// @notice The amount of time required to pass after a keeper has bonded assets for it to be able to activate\n  /// @return _days The required bondTime in days\n  function bondTime() external view returns (uint256 _days);\n\n  /// @notice The amount of time required to pass before a keeper can unbond what he has bonded\n  /// @return _days The required unbondTime in days\n  function unbondTime() external view returns (uint256 _days);\n\n  /// @notice The minimum amount of liquidity required to fund a job per liquidity\n  /// @return _amount The minimum amount of liquidity in KP3R\n  function liquidityMinimum() external view returns (uint256 _amount);\n\n  /// @notice The amount of time between each scheduled credits reward given to a job\n  /// @return _days The reward period in days\n  function rewardPeriodTime() external view returns (uint256 _days);\n\n  /// @notice The inflation period is the denominator used to regulate the emission of KP3R\n  /// @return _period The denominator used to regulate the emission of KP3R\n  function inflationPeriod() external view returns (uint256 _period);\n\n  /// @notice The fee to be sent to governance when a user adds liquidity to a job\n  /// @return _amount The fee amount to be sent to governance when a user adds liquidity to a job\n  function fee() external view returns (uint256 _amount);\n\n  // solhint-disable func-name-mixedcase\n  /// @notice The base that will be used to calculate the fee\n  /// @return _base The base that will be used to calculate the fee\n  function BASE() external view returns (uint256 _base);\n\n  /// @notice The minimum rewardPeriodTime value to be set\n  /// @return _minPeriod The minimum reward period in seconds\n  function MIN_REWARD_PERIOD_TIME() external view returns (uint256 _minPeriod);\n\n  /// @notice Maps an address to a boolean to determine whether the address is a slasher or not.\n  /// @return _isSlasher Whether the address is a slasher or not\n  function slashers(address _slasher) external view returns (bool _isSlasher);\n\n  /// @notice Maps an address to a boolean to determine whether the address is a disputer or not.\n  /// @return _isDisputer Whether the address is a disputer or not\n  function disputers(address _disputer) external view returns (bool _isDisputer);\n\n  /// @notice Tracks the total KP3R earnings of a keeper since it started working\n  /// @return _workCompleted Total KP3R earnings of a keeper since it started working\n  function workCompleted(address _keeper) external view returns (uint256 _workCompleted);\n\n  /// @notice Tracks when a keeper was first registered\n  /// @return _timestamp The time at which the keeper was first registered\n  function firstSeen(address _keeper) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks if a keeper or job has a pending dispute\n  /// @return _disputed Whether a keeper or job has a pending dispute\n  function disputes(address _keeperOrJob) external view returns (bool _disputed);\n\n  /// @notice Allows governance to create a dispute for a given keeper/job\n  /// @param _jobOrKeeper The address in dispute\n  function dispute(address _jobOrKeeper) external;\n\n  /// @notice Allows governance to resolve a dispute on a keeper/job\n  /// @param _jobOrKeeper The address cleared\n  function resolve(address _jobOrKeeper) external;\n\n  /// @notice Tracks how much a keeper has bonded of a certain token\n  /// @return _bonds Amount of a certain token that a keeper has bonded\n  function bonds(address _keeper, address _bond) external view returns (uint256 _bonds);\n\n  /// @notice The current token credits available for a job\n  /// @return _amount The amount of token credits available for a job\n  function jobTokenCredits(address _job, address _token) external view returns (uint256 _amount);\n\n  /// @notice Tracks the amount of assets deposited in pending bonds\n  /// @return _pendingBonds Amount of a certain asset a keeper has unbonding\n  function pendingBonds(address _keeper, address _bonding) external view returns (uint256 _pendingBonds);\n\n  /// @notice Tracks when a bonding for a keeper can be activated\n  /// @return _timestamp Time at which the bonding for a keeper can be activated\n  function canActivateAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks when keeper bonds are ready to be withdrawn\n  /// @return _timestamp Time at which the keeper bonds are ready to be withdrawn\n  function canWithdrawAfter(address _keeper, address _bonding) external view returns (uint256 _timestamp);\n\n  /// @notice Tracks how much keeper bonds are to be withdrawn\n  /// @return _pendingUnbonds The amount of keeper bonds that are to be withdrawn\n  function pendingUnbonds(address _keeper, address _bonding) external view returns (uint256 _pendingUnbonds);\n\n  /// @notice Checks whether the address has ever bonded an asset\n  /// @return _hasBonded Whether the address has ever bonded an asset\n  function hasBonded(address _keeper) external view returns (bool _hasBonded);\n\n  /// @notice Last block where tokens were added to the job [job => token => timestamp]\n  /// @return _timestamp The last block where tokens were added to the job\n  function jobTokenCreditsAddedAt(address _job, address _token) external view returns (uint256 _timestamp);\n\n  // Methods\n\n  /// @notice Add credit to a job to be paid out for work\n  /// @param _job The address of the job being credited\n  /// @param _token The address of the token being credited\n  /// @param _amount The amount of credit being added\n  function addTokenCreditsToJob(\n    address _job,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  /// @notice Withdraw credit from a job\n  /// @param _job The address of the job from which the credits are withdrawn\n  /// @param _token The address of the token being withdrawn\n  /// @param _amount The amount of token to be withdrawn\n  /// @param _receiver The user that will receive tokens\n  function withdrawTokenCreditsFromJob(\n    address _job,\n    address _token,\n    uint256 _amount,\n    address _receiver\n  ) external;\n\n  /// @notice Lists liquidity pairs\n  /// @return _list An array of addresses with all the approved liquidity pairs\n  function approvedLiquidities() external view returns (address[] memory _list);\n\n  /// @notice Amount of liquidity in a specified job\n  /// @param _job The address of the job being checked\n  /// @param _liquidity The address of the liquidity we are checking\n  /// @return _amount Amount of liquidity in the specified job\n  function liquidityAmount(address _job, address _liquidity) external view returns (uint256 _amount);\n\n  /// @notice Last time the job was rewarded liquidity credits\n  /// @param _job The address of the job being checked\n  /// @return _timestamp Timestamp of the last time the job was rewarded liquidity credits\n  function rewardedAt(address _job) external view returns (uint256 _timestamp);\n\n  /// @notice Last time the job was worked\n  /// @param _job The address of the job being checked\n  /// @return _timestamp Timestamp of the last time the job was worked\n  function workedAt(address _job) external view returns (uint256 _timestamp);\n\n  /// @notice Maps the job to the owner of the job (job => user)\n  /// @return _owner The addres of the owner of the job\n  function jobOwner(address _job) external view returns (address _owner);\n\n  /// @notice Maps the owner of the job to its pending owner (job => user)\n  /// @return _pendingOwner The address of the pending owner of the job\n  function jobPendingOwner(address _job) external view returns (address _pendingOwner);\n\n  /// @notice Maps the jobs that have requested a migration to the address they have requested to migrate to\n  /// @return _toJob The address to which the job has requested to migrate to\n  function pendingJobMigrations(address _fromJob) external view returns (address _toJob);\n\n  // Methods\n\n  /// @notice Sets the Keep3rHelper address\n  /// @param _keep3rHelper The Keep3rHelper address\n  function setKeep3rHelper(address _keep3rHelper) external;\n\n  /// @notice Sets the Keep3rV1 address\n  /// @param _keep3rV1 The Keep3rV1 address\n  function setKeep3rV1(address _keep3rV1) external;\n\n  /// @notice Sets the Keep3rV1Proxy address\n  /// @param _keep3rV1Proxy The Keep3rV1Proxy address\n  function setKeep3rV1Proxy(address _keep3rV1Proxy) external;\n\n  /// @notice Sets the KP3R-WETH pool address\n  /// @param _kp3rWethPool The KP3R-WETH pool address\n  function setKp3rWethPool(address _kp3rWethPool) external;\n\n  /// @notice Sets the bond time required to activate as a keeper\n  /// @param _bond The new bond time\n  function setBondTime(uint256 _bond) external;\n\n  /// @notice Sets the unbond time required unbond what has been bonded\n  /// @param _unbond The new unbond time\n  function setUnbondTime(uint256 _unbond) external;\n\n  /// @notice Sets the minimum amount of liquidity required to fund a job\n  /// @param _liquidityMinimum The new minimum amount of liquidity\n  function setLiquidityMinimum(uint256 _liquidityMinimum) external;\n\n  /// @notice Sets the time required to pass between rewards for jobs\n  /// @param _rewardPeriodTime The new amount of time required to pass between rewards\n  function setRewardPeriodTime(uint256 _rewardPeriodTime) external;\n\n  /// @notice Sets the new inflation period\n  /// @param _inflationPeriod The new inflation period\n  function setInflationPeriod(uint256 _inflationPeriod) external;\n\n  /// @notice Sets the new fee\n  /// @param _fee The new fee\n  function setFee(uint256 _fee) external;\n\n  /// @notice Registers a slasher by updating the slashers mapping\n  function addSlasher(address _slasher) external;\n\n  /// @notice Removes a slasher by updating the slashers mapping\n  function removeSlasher(address _slasher) external;\n\n  /// @notice Registers a disputer by updating the disputers mapping\n  function addDisputer(address _disputer) external;\n\n  /// @notice Removes a disputer by updating the disputers mapping\n  function removeDisputer(address _disputer) external;\n\n  /// @notice Lists all jobs\n  /// @return _jobList Array with all the jobs in _jobs\n  function jobs() external view returns (address[] memory _jobList);\n\n  /// @notice Lists all keepers\n  /// @return _keeperList Array with all the jobs in keepers\n  function keepers() external view returns (address[] memory _keeperList);\n\n  /// @notice Beginning of the bonding process\n  /// @param _bonding The asset being bound\n  /// @param _amount The amount of bonding asset being bound\n  function bond(address _bonding, uint256 _amount) external;\n\n  /// @notice Beginning of the unbonding process\n  /// @param _bonding The asset being unbound\n  /// @param _amount Allows for partial unbonding\n  function unbond(address _bonding, uint256 _amount) external;\n\n  /// @notice End of the bonding process after bonding time has passed\n  /// @param _bonding The asset being activated as bond collateral\n  function activate(address _bonding) external;\n\n  /// @notice Withdraw funds after unbonding has finished\n  /// @param _bonding The asset to withdraw from the bonding pool\n  function withdraw(address _bonding) external;\n\n  /// @notice Allows governance to slash a keeper based on a dispute\n  /// @param _keeper The address being slashed\n  /// @param _bonded The asset being slashed\n  /// @param _amount The amount being slashed\n  function slash(\n    address _keeper,\n    address _bonded,\n    uint256 _amount\n  ) external;\n\n  /// @notice Blacklists a keeper from participating in the network\n  /// @param _keeper The address being slashed\n  function revoke(address _keeper) external;\n\n  /// @notice Allows any caller to add a new job\n  /// @param _job Address of the contract for which work should be performed\n  function addJob(address _job) external;\n\n  /// @notice Returns the liquidity credits of a given job\n  /// @param _job The address of the job of which we want to know the liquidity credits\n  /// @return _amount The liquidity credits of a given job\n  function jobLiquidityCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Returns the credits of a given job for the current period\n  /// @param _job The address of the job of which we want to know the period credits\n  /// @return _amount The credits the given job has at the current period\n  function jobPeriodCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Calculates the total credits of a given job\n  /// @param _job The address of the job of which we want to know the total credits\n  /// @return _amount The total credits of the given job\n  function totalJobCredits(address _job) external view returns (uint256 _amount);\n\n  /// @notice Calculates how many credits should be rewarded periodically for a given liquidity amount\n  /// @dev _periodCredits = underlying KP3Rs for given liquidity amount * rewardPeriod / inflationPeriod\n  /// @param _liquidity The liquidity to provide\n  /// @param _amount The amount of liquidity to provide\n  /// @return _periodCredits The amount of KP3R periodically minted for the given liquidity\n  function quoteLiquidity(address _liquidity, uint256 _amount) external view returns (uint256 _periodCredits);\n\n  /// @notice Observes the current state of the liquidity pair being observed and updates TickCache with the information\n  /// @param _liquidity The liquidity pair being observed\n  /// @return _tickCache The updated TickCache\n  function observeLiquidity(address _liquidity) external view returns (TickCache memory _tickCache);\n\n  /// @notice Gifts liquidity credits to the specified job\n  /// @param _job The address of the job being credited\n  /// @param _amount The amount of liquidity credits to gift\n  function forceLiquidityCreditsToJob(address _job, uint256 _amount) external;\n\n  /// @notice Approve a liquidity pair for being accepted in future\n  /// @param _liquidity The address of the liquidity accepted\n  function approveLiquidity(address _liquidity) external;\n\n  /// @notice Revoke a liquidity pair from being accepted in future\n  /// @param _liquidity The liquidity no longer accepted\n  function revokeLiquidity(address _liquidity) external;\n\n  /// @notice Allows anyone to fund a job with liquidity\n  /// @param _job The address of the job to assign liquidity to\n  /// @param _liquidity The liquidity being added\n  /// @param _amount The amount of liquidity tokens to add\n  function addLiquidityToJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n\n  /// @notice Unbond liquidity for a job\n  /// @dev Can only be called by the job's owner\n  /// @param _job The address of the job being unbound from\n  /// @param _liquidity The liquidity being unbound\n  /// @param _amount The amount of liquidity being removed\n  function unbondLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n\n  /// @notice Withdraw liquidity from a job\n  /// @param _job The address of the job being withdrawn from\n  /// @param _liquidity The liquidity being withdrawn\n  /// @param _receiver The address that will receive the withdrawn liquidity\n  function withdrawLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    address _receiver\n  ) external;\n\n  /// @notice Confirms if the current keeper is registered, can be used for general (non critical) functions\n  /// @param _keeper The keeper being investigated\n  /// @return _isKeeper Whether the address passed as a parameter is a keeper or not\n  function isKeeper(address _keeper) external returns (bool _isKeeper);\n\n  /// @notice Confirms if the current keeper is registered and has a minimum bond of any asset. Should be used for protected functions\n  /// @param _keeper The keeper to check\n  /// @param _bond The bond token being evaluated\n  /// @param _minBond The minimum amount of bonded tokens\n  /// @param _earned The minimum funds earned in the keepers lifetime\n  /// @param _age The minimum keeper age required\n  /// @return _isBondedKeeper Whether the `_keeper` meets the given requirements\n  function isBondedKeeper(\n    address _keeper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) external returns (bool _isBondedKeeper);\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Automatically calculates the payment for the keeper\n  /// @param _keeper Address of the keeper that performed the work\n  function worked(address _keeper) external;\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Pays the keeper that performs the work with KP3R\n  /// @param _keeper Address of the keeper that performed the work\n  /// @param _payment The reward that should be allocated for the job\n  function bondedPayment(address _keeper, uint256 _payment) external;\n\n  /// @notice Implemented by jobs to show that a keeper performed work\n  /// @dev Pays the keeper that performs the work with a specific token\n  /// @param _token The asset being awarded to the keeper\n  /// @param _keeper Address of the keeper that performed the work\n  /// @param _amount The reward that should be allocated\n  function directTokenPayment(\n    address _token,\n    address _keeper,\n    uint256 _amount\n  ) external;\n\n  /// @notice Proposes a new address to be the owner of the job\n  function changeJobOwnership(address _job, address _newOwner) external;\n\n  /// @notice The proposed address accepts to be the owner of the job\n  function acceptJobOwnership(address _job) external;\n\n  /// @notice Initializes the migration process for a job by adding the request to the pendingJobMigrations mapping\n  /// @param _fromJob The address of the job that is requesting to migrate\n  /// @param _toJob The address at which the job is requesting to migrate\n  function migrateJob(address _fromJob, address _toJob) external;\n\n  /// @notice Completes the migration process for a job\n  /// @dev Unbond/withdraw process doesn't get migrated\n  /// @param _fromJob The address of the job that requested to migrate\n  /// @param _toJob The address to which the job wants to migrate to\n  function acceptJobMigration(address _fromJob, address _toJob) external;\n\n  /// @notice Allows governance or slasher to slash a job specific token\n  /// @param _job The address of the job from which the token will be slashed\n  /// @param _token The address of the token that will be slashed\n  /// @param _amount The amount of the token that will be slashed\n  function slashTokenFromJob(\n    address _job,\n    address _token,\n    uint256 _amount\n  ) external;\n\n  /// @notice Allows governance or a slasher to slash liquidity from a job\n  /// @param _job The address being slashed\n  /// @param _liquidity The address of the liquidity that will be slashed\n  /// @param _amount The amount of liquidity that will be slashed\n  function slashLiquidityFromJob(\n    address _job,\n    address _liquidity,\n    uint256 _amount\n  ) external;\n}\n"
    },
    "solidity/interfaces/utils/IGovernable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IBaseErrors.sol';\n\ninterface IGovernable is IBaseErrors {\n  // events\n\n  /// @notice Emitted when a new pending governor is set\n  /// @param _governor Address of the current governor\n  /// @param _pendingGovernor Address of the proposed next governor\n  event PendingGovernorSet(address _governor, address _pendingGovernor);\n\n  /// @notice Emitted when a new governor is set\n  /// @param _newGovernor Address of the new governor\n  event PendingGovernorAccepted(address _newGovernor);\n\n  // errors\n\n  /// @notice Throws if a non-governor user tries to call a OnlyGovernor function\n  error OnlyGovernor();\n  /// @notice Throws if a non-pending-governor user tries to call a OnlyPendingGovernor function\n  error OnlyPendingGovernor();\n\n  // views\n\n  /// @return _governor Address of the current governor\n  function governor() external view returns (address _governor);\n\n  /// @return _pendingGovernor Address of the current pending governor\n  function pendingGovernor() external view returns (address _pendingGovernor);\n\n  // methods\n\n  /// @notice Allows a governor to propose a new governor\n  /// @param _pendingGovernor Address of the proposed new governor\n  function setPendingGovernor(address _pendingGovernor) external;\n\n  /// @notice Allows a proposed governor to accept the governance\n  function acceptPendingGovernor() external;\n}\n"
    },
    "solidity/interfaces/utils/IBaseErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IBaseErrors {\n  /// @notice Throws if a variable is assigned to the zero address\n  error ZeroAddress();\n\n  /// @notice Throws if a set of correlated input param arrays differ in lengths\n  error WrongLengths();\n}\n"
    },
    "solidity/interfaces/utils/IKeep3rBondedJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IKeep3rJob.sol';\n\ninterface IKeep3rBondedJob is IKeep3rJob {\n  // events\n\n  /// @notice Emitted when a new set of requirements is set\n  /// @param _bond Address of the token required to bond to work the job\n  /// @param _minBond Amount of tokens required to bond to work the job\n  /// @param _earned Amount of KP3R earnings required to work the job\n  /// @param _age Amount of seconds since keeper registration required to work the job\n  event Keep3rRequirementsSet(address _bond, uint256 _minBond, uint256 _earned, uint256 _age);\n\n  // views\n\n  /// @return _requiredBond Address of the token required to bond to work the job\n  function requiredBond() external view returns (address _requiredBond);\n\n  /// @return _requiredMinBond Amount of tokens required to bond to work the job\n  function requiredMinBond() external view returns (uint256 _requiredMinBond);\n\n  /// @return _requiredEarnings Amount of KP3R earnings required to work the job\n  function requiredEarnings() external view returns (uint256 _requiredEarnings);\n\n  /// @return _requiredAge Amount of seconds since keeper registration required to work the job\n  function requiredAge() external view returns (uint256 _requiredAge);\n\n  // methods\n\n  /// @notice Allows the governor to set new requirements to work the job\n  /// @param _bond Address of the token required to bond to work the job\n  /// @param _minBond Amount of tokens required to bond to work the job\n  /// @param _earned Amount of KP3R earnings required to work the job\n  /// @param _age Amount of seconds since keeper registration required to work the job\n  function setKeep3rRequirements(\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) external;\n}\n"
    },
    "solidity/interfaces/utils/IOnlyEOA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IOnlyEOA {\n  // events\n\n  /// @notice Emitted when onlyEOA is set\n  event OnlyEOASet(bool _onlyEOA);\n\n  // errors\n\n  /// @notice Throws when keeper is not tx.origin\n  error OnlyEOA();\n\n  // views\n\n  /// @return _onlyEOA Whether the keeper is required to be an EOA or not\n  function onlyEOA() external returns (bool _onlyEOA);\n\n  // methods\n\n  /// @notice Allows governor to set the onlyEOA condition\n  /// @param _onlyEOA Whether the keeper is required to be an EOA or not\n  function setOnlyEOA(bool _onlyEOA) external;\n}\n"
    },
    "solidity/interfaces/external/IStealthTx.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.4;\n\ninterface IStealthTx {\n  event StealthVaultSet(address _stealthVault);\n  event PenaltySet(uint256 _penalty);\n  event MigratedStealthVault(address _migratedTo);\n\n  function stealthVault() external view returns (address);\n\n  function penalty() external view returns (uint256);\n\n  function setStealthVault(address _stealthVault) external;\n\n  function setPenalty(uint256 _penalty) external;\n}\n"
    },
    "solidity/contracts/for-test/Keep3rMeteredStealthJobForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../utils/Keep3rMeteredStealthJob.sol';\n\ncontract Keep3rMeteredStealthJobForTest is Keep3rMeteredStealthJob {\n  constructor(address _stealthRelayer) Governable(msg.sender) {\n    _setStealthRelayer(_stealthRelayer);\n  }\n}\n"
    },
    "solidity/contracts/HarvestV2Keep3rStealthJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n\nCoded for Yearn Finance with ♥ by\n\n██████╗░███████╗███████╗██╗  ░██╗░░░░░░░██╗░█████╗░███╗░░██╗██████╗░███████╗██████╗░██╗░░░░░░█████╗░███╗░░██╗██████╗░\n██╔══██╗██╔════╝██╔════╝██║  ░██║░░██╗░░██║██╔══██╗████╗░██║██╔══██╗██╔════╝██╔══██╗██║░░░░░██╔══██╗████╗░██║██╔══██╗\n██║░░██║█████╗░░█████╗░░██║  ░╚██╗████╗██╔╝██║░░██║██╔██╗██║██║░░██║█████╗░░██████╔╝██║░░░░░███████║██╔██╗██║██║░░██║\n██║░░██║██╔══╝░░██╔══╝░░██║  ░░████╔═████║░██║░░██║██║╚████║██║░░██║██╔══╝░░██╔══██╗██║░░░░░██╔══██║██║╚████║██║░░██║\n██████╔╝███████╗██║░░░░░██║  ░░╚██╔╝░╚██╔╝░╚█████╔╝██║░╚███║██████╔╝███████╗██║░░██║███████╗██║░░██║██║░╚███║██████╔╝\n╚═════╝░╚══════╝╚═╝░░░░░╚═╝  ░░░╚═╝░░░╚═╝░░░╚════╝░╚═╝░░╚══╝╚═════╝░╚══════╝╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝╚═╝░░╚══╝╚═════╝░\n\nhttps://defi.sucks\n\n*/\n\npragma solidity >=0.8.9 <0.9.0;\n\nimport './V2KeeperJob.sol';\nimport './utils/Pausable.sol';\nimport './utils/Keep3rMeteredStealthJob.sol';\nimport '../interfaces/IV2Keep3rStealthJob.sol';\n\ncontract HarvestV2Keep3rStealthJob is IV2Keep3rStealthJob, V2KeeperJob, Pausable, Keep3rMeteredStealthJob {\n  constructor(\n    address _governor,\n    address _mechanicsRegistry,\n    address _stealthRelayer,\n    address _v2Keeper,\n    uint256 _workCooldown,\n    address _keep3r,\n    address _keep3rHelper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age,\n    bool _onlyEOA\n  ) V2KeeperJob(_governor, _v2Keeper, _mechanicsRegistry, _workCooldown) {\n    _setKeep3r(_keep3r);\n    _setKeep3rHelper(_keep3rHelper);\n    _setStealthRelayer(_stealthRelayer);\n    _setKeep3rRequirements(_bond, _minBond, _earned, _age);\n    _setOnlyEOA(_onlyEOA);\n    _setGasBonus(127_000); // calculated fixed bonus to compensate unaccounted gas\n    _setGasMultiplier((gasMultiplier * 850) / 1_000); // expected 15% refunded gas\n  }\n\n  // views\n\n  /// @inheritdoc IV2KeeperJob\n  function workable(address _strategy) external view returns (bool _isWorkable) {\n    return _workable(_strategy);\n  }\n\n  // methods\n\n  /// @inheritdoc IV2KeeperJob\n  function work(address _strategy) external upkeepStealthy notPaused {\n    _workInternal(_strategy);\n  }\n\n  /// @inheritdoc IV2KeeperJob\n  function forceWork(address _strategy) external onlyStealthRelayer {\n    address _caller = IStealthRelayer(stealthRelayer).caller();\n    _validateGovernorOrMechanic(_caller);\n    _forceWork(_strategy);\n  }\n\n  /// @inheritdoc IV2Keep3rStealthJob\n  function forceWorkUnsafe(address _strategy) external onlyGovernorOrMechanic {\n    _forceWork(_strategy);\n  }\n\n  // internals\n\n  function _workable(address _strategy) internal view override returns (bool _isWorkable) {\n    if (!super._workable(_strategy)) return false;\n    return IBaseStrategy(_strategy).harvestTrigger(_getCallCosts(_strategy));\n  }\n\n  function _work(address _strategy) internal override {\n    v2Keeper.harvest(_strategy);\n  }\n}\n"
    },
    "solidity/contracts/V2KeeperJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9 <0.9.0;\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\n\nimport './utils/GasBaseFee.sol';\nimport './utils/MachineryReady.sol';\nimport '../interfaces/IV2KeeperJob.sol';\nimport '../interfaces/external/IV2Keeper.sol';\nimport '../interfaces/external/IBaseStrategy.sol';\n\nabstract contract V2KeeperJob is IV2KeeperJob, MachineryReady, GasBaseFee {\n  using EnumerableSet for EnumerableSet.AddressSet;\n  /// @inheritdoc IV2KeeperJob\n  IV2Keeper public v2Keeper;\n\n  EnumerableSet.AddressSet internal _availableStrategies;\n  /// @inheritdoc IV2KeeperJob\n  mapping(address => uint256) public requiredAmount;\n  /// @inheritdoc IV2KeeperJob\n  mapping(address => uint256) public lastWorkAt;\n  /// @inheritdoc IV2KeeperJob\n  uint256 public workCooldown;\n\n  constructor(\n    address _governor,\n    address _v2Keeper,\n    address _mechanicsRegistry,\n    uint256 _workCooldown\n  ) Governable(_governor) MachineryReady(_mechanicsRegistry) {\n    v2Keeper = IV2Keeper(_v2Keeper);\n    if (_workCooldown > 0) _setWorkCooldown(_workCooldown);\n  }\n\n  // views\n\n  /// @inheritdoc IV2KeeperJob\n  function strategies() public view returns (address[] memory _strategies) {\n    _strategies = new address[](_availableStrategies.length());\n    for (uint256 _i; _i < _availableStrategies.length(); _i++) {\n      _strategies[_i] = _availableStrategies.at(_i);\n    }\n  }\n\n  // setters\n\n  /// @inheritdoc IV2KeeperJob\n  function setV2Keeper(address _v2Keeper) external onlyGovernor {\n    _setV2Keeper(_v2Keeper);\n  }\n\n  /// @inheritdoc IV2KeeperJob\n  function setWorkCooldown(uint256 _workCooldown) external onlyGovernorOrMechanic {\n    _setWorkCooldown(_workCooldown);\n  }\n\n  /// @inheritdoc IV2KeeperJob\n  function addStrategy(address _strategy, uint256 _requiredAmount) external onlyGovernorOrMechanic {\n    _addStrategy(_strategy, _requiredAmount);\n  }\n\n  /// @inheritdoc IV2KeeperJob\n  function addStrategies(address[] calldata _strategies, uint256[] calldata _requiredAmounts) external onlyGovernorOrMechanic {\n    if (_strategies.length != _requiredAmounts.length) revert WrongLengths();\n    for (uint256 _i; _i < _strategies.length; _i++) {\n      _addStrategy(_strategies[_i], _requiredAmounts[_i]);\n    }\n  }\n\n  /// @inheritdoc IV2KeeperJob\n  function updateRequiredAmount(address _strategy, uint256 _requiredAmount) external onlyGovernorOrMechanic {\n    _updateRequiredAmount(_strategy, _requiredAmount);\n  }\n\n  /// @inheritdoc IV2KeeperJob\n  function updateRequiredAmounts(address[] calldata _strategies, uint256[] calldata _requiredAmounts) external onlyGovernorOrMechanic {\n    if (_strategies.length != _requiredAmounts.length) revert WrongLengths();\n    for (uint256 _i; _i < _strategies.length; _i++) {\n      _updateRequiredAmount(_strategies[_i], _requiredAmounts[_i]);\n    }\n  }\n\n  /// @inheritdoc IV2KeeperJob\n  function removeStrategy(address _strategy) external onlyGovernorOrMechanic {\n    _removeStrategy(_strategy);\n  }\n\n  // internals\n\n  function _setV2Keeper(address _v2Keeper) internal {\n    v2Keeper = IV2Keeper(_v2Keeper);\n  }\n\n  function _setWorkCooldown(uint256 _workCooldown) internal {\n    if (_workCooldown == 0) revert ZeroCooldown();\n    workCooldown = _workCooldown;\n  }\n\n  function _addStrategy(address _strategy, uint256 _requiredAmount) internal {\n    if (_availableStrategies.contains(_strategy)) revert StrategyAlreadyAdded();\n    _setRequiredAmount(_strategy, _requiredAmount);\n    emit StrategyAdded(_strategy, _requiredAmount);\n    _availableStrategies.add(_strategy);\n  }\n\n  function _updateRequiredAmount(address _strategy, uint256 _requiredAmount) internal {\n    if (!_availableStrategies.contains(_strategy)) revert StrategyNotAdded();\n    _setRequiredAmount(_strategy, _requiredAmount);\n    emit StrategyModified(_strategy, _requiredAmount);\n  }\n\n  function _removeStrategy(address _strategy) internal {\n    if (!_availableStrategies.contains(_strategy)) revert StrategyNotAdded();\n    delete requiredAmount[_strategy];\n    _availableStrategies.remove(_strategy);\n    emit StrategyRemoved(_strategy);\n  }\n\n  function _setRequiredAmount(address _strategy, uint256 _requiredAmount) internal {\n    requiredAmount[_strategy] = _requiredAmount;\n  }\n\n  function _workable(address _strategy) internal view virtual returns (bool) {\n    if (!_availableStrategies.contains(_strategy)) revert StrategyNotAdded();\n    if (workCooldown == 0 || block.timestamp > lastWorkAt[_strategy] + workCooldown) return true;\n    return false;\n  }\n\n  function _getCallCosts(address _strategy) internal view returns (uint256 _callCost) {\n    uint256 _gasAmount = requiredAmount[_strategy];\n    if (_gasAmount == 0) return 0;\n    return _gasAmount * _gasPrice();\n  }\n\n  function _workInternal(address _strategy) internal {\n    if (!_workable(_strategy)) revert StrategyNotWorkable();\n    lastWorkAt[_strategy] = block.timestamp;\n    _work(_strategy);\n    emit KeeperWorked(_strategy);\n  }\n\n  function _forceWork(address _strategy) internal {\n    _work(_strategy);\n    emit ForceWorked(_strategy);\n  }\n\n  /// @dev This function should be implemented on the base contract\n  function _work(address _strategy) internal virtual {}\n}\n"
    },
    "solidity/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Governable.sol';\nimport '../../interfaces/utils/IPausable.sol';\n\nabstract contract Pausable is IPausable, Governable {\n  /// @inheritdoc IPausable\n  bool public paused;\n\n  // setters\n\n  /// @inheritdoc IPausable\n  function setPause(bool _paused) external onlyGovernor {\n    _setPause(_paused);\n  }\n\n  // modifiers\n\n  modifier notPaused() {\n    if (paused) revert Paused();\n    _;\n  }\n\n  // internals\n\n  function _setPause(bool _paused) internal {\n    if (paused == _paused) revert NoChangeInPause();\n    paused = _paused;\n    emit PauseSet(_paused);\n  }\n}\n"
    },
    "solidity/interfaces/IV2Keep3rStealthJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IV2KeeperJob.sol';\n\ninterface IV2Keep3rStealthJob is IV2KeeperJob {\n  /// @notice Function to be called by governor or mechanic that triggers the execution of the given strategy\n  /// @notice This function bypasses the stealth relayer checks\n  /// @param _strategy Address of the strategy to be worked\n  function forceWorkUnsafe(address _strategy) external;\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/EnumerableSet.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position of the value in the `values` array, plus 1 because index 0\n        // means a value is not in the set.\n        mapping(bytes32 => uint256) _indexes;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._indexes[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We read and store the value's index to prevent multiple reads from the same storage slot\n        uint256 valueIndex = set._indexes[value];\n\n        if (valueIndex != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 toDeleteIndex = valueIndex - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (lastIndex != toDeleteIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the last value to the index where the value to delete is\n                set._values[toDeleteIndex] = lastValue;\n                // Update the index for the moved value\n                set._indexes[lastValue] = valueIndex; // Replace lastValue's index to valueIndex\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the index for the deleted slot\n            delete set._indexes[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._indexes[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        return _values(set._inner);\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "solidity/contracts/utils/GasBaseFee.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9 <0.9.0;\n\nabstract contract GasBaseFee {\n  // internals\n  function _gasPrice() internal view virtual returns (uint256) {\n    return block.basefee;\n  }\n}\n"
    },
    "solidity/contracts/utils/MachineryReady.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '@yearn-mechanics/contract-utils/solidity/contracts/utils/Machinery.sol';\nimport './Governable.sol';\n\nabstract contract MachineryReady is Machinery, Governable {\n  // errors\n\n  /// @notice Throws when a OnlyGovernorOrMechanic function is called from an unknown address\n  error OnlyGovernorOrMechanic();\n\n  constructor(address _mechanicsRegistry) Machinery(_mechanicsRegistry) {}\n\n  // methods\n\n  /// @notice Allows governor to set a new MechanicsRegistry contract\n  /// @param _mechanicsRegistry Address of the new MechanicsRegistry contract\n  function setMechanicsRegistry(address _mechanicsRegistry) external override onlyGovernor {\n    _setMechanicsRegistry(_mechanicsRegistry);\n  }\n\n  // modifiers\n\n  modifier onlyGovernorOrMechanic() {\n    _validateGovernorOrMechanic(msg.sender);\n    _;\n  }\n\n  // internals\n\n  function _validateGovernorOrMechanic(address _user) internal view {\n    if (_user != governor && !isMechanic(_user)) revert OnlyGovernorOrMechanic();\n  }\n}\n"
    },
    "solidity/interfaces/IV2KeeperJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\nimport './external/IV2Keeper.sol';\n\ninterface IV2KeeperJob {\n  // errors\n\n  /// @notice Throws if the strategy being added has already been added\n  error StrategyAlreadyAdded();\n  /// @notice Throws if the strategy being summoned is not added\n  error StrategyNotAdded();\n  /// @notice Throws if a keeper tries to work a non-workable strategy\n  error StrategyNotWorkable();\n  /// @notice Throws if the cooldown is being set to 0\n  error ZeroCooldown();\n\n  // events\n\n  /// @notice Emitted when a new strategy is added\n  /// @param _strategy Address of the strategy being added\n  /// @param _requiredAmount Estimated amount of gas required to trigger the strategy\n  event StrategyAdded(address _strategy, uint256 _requiredAmount);\n\n  /// @notice Emitted when a strategy is modified\n  /// @param _strategy Address of the strategy being modified\n  /// @param _requiredAmount New estimated amount of gas required to trigger the strategy\n  event StrategyModified(address _strategy, uint256 _requiredAmount);\n\n  /// @notice Emitted when a strategy is removed\n  /// @param _strategy Address of the strategy being removed\n  event StrategyRemoved(address _strategy);\n\n  /// @notice Emitted when a strategy is worked\n  /// @param _strategy Address of the strategy being worked\n  event KeeperWorked(address _strategy);\n\n  /// @notice Emitted when a strategy is force-worked by governor or mechanic\n  /// @param _strategy Address of the strategy being force-worked\n  event ForceWorked(address _strategy);\n\n  // views\n\n  /// @return _v2Keeper Address of v2Keeper\n  function v2Keeper() external view returns (IV2Keeper _v2Keeper);\n\n  /// @return _strategies List of added strategies\n  function strategies() external view returns (address[] memory _strategies);\n\n  /// @return _workCooldown Amount of seconds to wait until a strategy can be worked again\n  function workCooldown() external view returns (uint256 _workCooldown);\n\n  /// @param _strategy Address of the strategy to query\n  /// @return _isWorkable Whether the queried strategy is workable or not\n  function workable(address _strategy) external view returns (bool _isWorkable);\n\n  /// @param _strategy Address of the strategy to query\n  /// @return _lastWorkAt Timestamp of the last time the strategy was worked\n  function lastWorkAt(address _strategy) external view returns (uint256 _lastWorkAt);\n\n  /// @param _strategy Address of the strategy to query\n  /// @return _requiredAmount Estimated amount of gas that the strategy requires to be executed\n  function requiredAmount(address _strategy) external view returns (uint256 _requiredAmount);\n\n  // methods\n\n  /// @param _v2Keeper Address of the new v2Keeper to set\n  function setV2Keeper(address _v2Keeper) external;\n\n  /// @param _workCooldown Amount of seconds to wait until a strategy can be worked again\n  function setWorkCooldown(uint256 _workCooldown) external;\n\n  /// @param _strategy Address of the strategy to add\n  /// @param _requiredAmount Amount of gas that the strategy requires to execute\n  function addStrategy(address _strategy, uint256 _requiredAmount) external;\n\n  /// @param _strategies Array of addresses of strategies to add\n  /// @param _requiredAmount Array of amount of gas that each strategy requires to execute\n  function addStrategies(address[] calldata _strategies, uint256[] calldata _requiredAmount) external;\n\n  /// @param _strategy Address of the strategy to modify\n  /// @param _requiredAmount New amount of gas that te strategy requires to execute\n  function updateRequiredAmount(address _strategy, uint256 _requiredAmount) external;\n\n  /// @param _strategies Array of addresses of strategies to modify\n  /// @param _requiredAmounts Array of new amounts of gas that each strategy requires to execute\n  function updateRequiredAmounts(address[] calldata _strategies, uint256[] calldata _requiredAmounts) external;\n\n  /// @param _strategy Address of the strategy to remove\n  function removeStrategy(address _strategy) external;\n\n  /// @notice Function to be called by the keeper that triggers the execution of the given strategy\n  /// @param _strategy Address of the strategy to be worked\n  function work(address _strategy) external;\n\n  /// @notice Function to be called by governor or mechanics that triggers the execution of the given strategy\n  /// @notice This function bypasses the workable checks\n  /// @param _strategy Address of the strategy to be worked\n  function forceWork(address _strategy) external;\n}\n"
    },
    "solidity/interfaces/external/IV2Keeper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.8;\n\ninterface IV2Keeper {\n  // Getters\n  function jobs() external view returns (address[] memory);\n\n  event JobAdded(address _job);\n  event JobRemoved(address _job);\n\n  // Setters\n  function addJobs(address[] calldata _jobs) external;\n\n  function addJob(address _job) external;\n\n  function removeJob(address _job) external;\n\n  // Jobs actions\n  function tend(address _strategy) external;\n\n  function harvest(address _strategy) external;\n}\n"
    },
    "solidity/interfaces/external/IBaseStrategy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\ninterface IBaseStrategy {\n  // events\n  event Harvested(uint256 _profit, uint256 _loss, uint256 _debtPayment, uint256 _debtOutstanding);\n\n  // views\n\n  function vault() external view returns (address _vault);\n\n  function strategist() external view returns (address _strategist);\n\n  function rewards() external view returns (address _rewards);\n\n  function keeper() external view returns (address _keeper);\n\n  function want() external view returns (address _want);\n\n  function name() external view returns (string memory _name);\n\n  function profitFactor() external view returns (uint256 _profitFactor);\n\n  function maxReportDelay() external view returns (uint256 _maxReportDelay);\n\n  function crv() external view returns (address _crv);\n\n  // setters\n  function setStrategist(address _strategist) external;\n\n  function setKeeper(address _keeper) external;\n\n  function setRewards(address _rewards) external;\n\n  function tendTrigger(uint256 _callCost) external view returns (bool);\n\n  function tend() external;\n\n  function harvestTrigger(uint256 _callCost) external view returns (bool);\n\n  function harvest() external;\n\n  function setBorrowCollateralizationRatio(uint256 _c) external;\n}\n"
    },
    "@yearn-mechanics/contract-utils/solidity/contracts/utils/Machinery.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport '@openzeppelin/contracts/utils/structs/EnumerableSet.sol';\nimport '../../interfaces/utils/IMachinery.sol';\nimport '../../interfaces/mechanics/IMechanicsRegistry.sol';\n\ncontract Machinery is IMachinery {\n  using EnumerableSet for EnumerableSet.AddressSet;\n\n  IMechanicsRegistry internal _mechanicsRegistry;\n\n  constructor(address __mechanicsRegistry) {\n    _setMechanicsRegistry(__mechanicsRegistry);\n  }\n\n  modifier onlyMechanic() {\n    require(_mechanicsRegistry.isMechanic(msg.sender), 'Machinery: not mechanic');\n    _;\n  }\n\n  function setMechanicsRegistry(address __mechanicsRegistry) external virtual override {\n    _setMechanicsRegistry(__mechanicsRegistry);\n  }\n\n  function _setMechanicsRegistry(address __mechanicsRegistry) internal {\n    _mechanicsRegistry = IMechanicsRegistry(__mechanicsRegistry);\n  }\n\n  // View helpers\n  function mechanicsRegistry() external view override returns (address _mechanicRegistry) {\n    return address(_mechanicsRegistry);\n  }\n\n  function isMechanic(address _mechanic) public view override returns (bool _isMechanic) {\n    return _mechanicsRegistry.isMechanic(_mechanic);\n  }\n}\n"
    },
    "@yearn-mechanics/contract-utils/solidity/interfaces/utils/IMachinery.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IMachinery {\n  // View helpers\n  function mechanicsRegistry() external view returns (address _mechanicsRegistry);\n\n  function isMechanic(address mechanic) external view returns (bool _isMechanic);\n\n  // Setters\n  function setMechanicsRegistry(address _mechanicsRegistry) external;\n}\n"
    },
    "@yearn-mechanics/contract-utils/solidity/interfaces/mechanics/IMechanicsRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IMechanicsRegistry {\n  event MechanicAdded(address _mechanic);\n  event MechanicRemoved(address _mechanic);\n\n  function addMechanic(address _mechanic) external;\n\n  function removeMechanic(address _mechanic) external;\n\n  function mechanics() external view returns (address[] memory _mechanicsList);\n\n  function isMechanic(address mechanic) external view returns (bool _isMechanic);\n}\n"
    },
    "solidity/interfaces/utils/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IGovernable.sol';\n\ninterface IPausable is IGovernable {\n  // events\n\n  /// @notice Emitted when the contract pause is switched\n  /// @param _paused Whether the contract is paused or not\n  event PauseSet(bool _paused);\n\n  // errors\n\n  /// @notice Throws when a keeper tries to work a paused contract\n  error Paused();\n\n  /// @notice Throws when governor tries to switch pause to the same state as before\n  error NoChangeInPause();\n\n  // views\n\n  /// @return _paused Whether the contract is paused or not\n  function paused() external view returns (bool _paused);\n\n  // methods\n\n  /// @notice Allows governor to pause or unpause the contract\n  /// @param _paused Whether the contract should be paused or not\n  function setPause(bool _paused) external;\n}\n"
    },
    "solidity/contracts/for-test/V2JobProxyForTest.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../../interfaces/IV2KeeperJob.sol';\nimport '../../interfaces/external/IStealthRelayer.sol';\n\ncontract V2JobProxyForTest {\n  address public stealthRelayer;\n\n  constructor(address _stealthRelayer) {\n    stealthRelayer = _stealthRelayer;\n  }\n\n  function callWork(address _job, address _strategy) external {\n    IV2KeeperJob(_job).work(_strategy);\n  }\n\n  function callExecuteAndPay(\n    address _job,\n    bytes memory _callData,\n    bytes32 _stealthHash,\n    uint256 _blockNumber,\n    uint256 _payment\n  ) external returns (bytes memory _returnData) {\n    return IStealthRelayer(stealthRelayer).executeAndPay(_job, _callData, _stealthHash, _blockNumber, _payment);\n  }\n}\n"
    },
    "solidity/contracts/for-test/V2KeeperJobForTest.sol": {
      "content": "//SPDX-License-Identifier: Unlicense\npragma solidity ^0.8.4;\n\nimport '../V2KeeperJob.sol';\n\ncontract V2KeeperJobForTest is V2KeeperJob {\n  constructor(\n    address _governor,\n    address _mechanicsRegistry,\n    address _v2Keeper,\n    uint256 _workCooldown\n  ) V2KeeperJob(_governor, _v2Keeper, _mechanicsRegistry, _workCooldown) {}\n\n  function internalWorkable(address _strategy) external view returns (bool) {\n    return _workable(_strategy);\n  }\n\n  function internalGetCallCosts(address _strategy) external view returns (uint256 _callCost) {\n    return _getCallCosts(_strategy);\n  }\n\n  function internalAddStrategy(address _strategy, uint256 _requiredAmount) external {\n    _addStrategy(_strategy, _requiredAmount);\n  }\n\n  // missing implementations\n\n  function workable(address _strategy) external view returns (bool) {}\n\n  function forceWork(address _strategy) external {}\n\n  function work(address _strategy) external {}\n}\n"
    },
    "solidity/contracts/TendV2Keep3rJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\n/*\n\nCoded for Yearn Finance with ♥ by\n\n██████╗░███████╗███████╗██╗  ░██╗░░░░░░░██╗░█████╗░███╗░░██╗██████╗░███████╗██████╗░██╗░░░░░░█████╗░███╗░░██╗██████╗░\n██╔══██╗██╔════╝██╔════╝██║  ░██║░░██╗░░██║██╔══██╗████╗░██║██╔══██╗██╔════╝██╔══██╗██║░░░░░██╔══██╗████╗░██║██╔══██╗\n██║░░██║█████╗░░█████╗░░██║  ░╚██╗████╗██╔╝██║░░██║██╔██╗██║██║░░██║█████╗░░██████╔╝██║░░░░░███████║██╔██╗██║██║░░██║\n██║░░██║██╔══╝░░██╔══╝░░██║  ░░████╔═████║░██║░░██║██║╚████║██║░░██║██╔══╝░░██╔══██╗██║░░░░░██╔══██║██║╚████║██║░░██║\n██████╔╝███████╗██║░░░░░██║  ░░╚██╔╝░╚██╔╝░╚█████╔╝██║░╚███║██████╔╝███████╗██║░░██║███████╗██║░░██║██║░╚███║██████╔╝\n╚═════╝░╚══════╝╚═╝░░░░░╚═╝  ░░░╚═╝░░░╚═╝░░░╚════╝░╚═╝░░╚══╝╚═════╝░╚══════╝╚═╝░░╚═╝╚══════╝╚═╝░░╚═╝╚═╝░░╚══╝╚═════╝░\n\nhttps://defi.sucks\n\n*/\n\npragma solidity >=0.8.9 <0.9.0;\n\nimport './V2KeeperJob.sol';\nimport './utils/Pausable.sol';\nimport './utils/Keep3rMeteredPublicJob.sol';\n\ncontract TendV2Keep3rJob is IKeep3rJob, V2KeeperJob, Pausable, Keep3rMeteredPublicJob {\n  constructor(\n    address _governor,\n    address _mechanicsRegistry,\n    address _v2Keeper,\n    uint256 _workCooldown,\n    address _keep3r,\n    address _keep3rHelper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age,\n    bool _onlyEOA\n  ) V2KeeperJob(_governor, _v2Keeper, _mechanicsRegistry, _workCooldown) {\n    _setKeep3r(_keep3r);\n    _setKeep3rHelper(_keep3rHelper);\n    _setKeep3rRequirements(_bond, _minBond, _earned, _age);\n    _setOnlyEOA(_onlyEOA);\n  }\n\n  // views\n\n  /// @inheritdoc IV2KeeperJob\n  function workable(address _strategy) external view returns (bool _isWorkable) {\n    return _workable(_strategy);\n  }\n\n  // methods\n\n  /// @inheritdoc IV2KeeperJob\n  function work(address _strategy) external upkeepMetered notPaused {\n    _workInternal(_strategy);\n  }\n\n  /// @inheritdoc IV2KeeperJob\n  function forceWork(address _strategy) external onlyGovernorOrMechanic {\n    _forceWork(_strategy);\n  }\n\n  // internals\n\n  function _workable(address _strategy) internal view override returns (bool _isWorkable) {\n    if (!super._workable(_strategy)) return false;\n    return IBaseStrategy(_strategy).tendTrigger(_getCallCosts(_strategy));\n  }\n\n  function _work(address _strategy) internal override {\n    v2Keeper.tend(_strategy);\n  }\n}\n"
    },
    "solidity/contracts/utils/Keep3rMeteredPublicJob.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Keep3rMeteredJob.sol';\nimport './Keep3rBondedJob.sol';\nimport './OnlyEOA.sol';\n\nabstract contract Keep3rMeteredPublicJob is Keep3rMeteredJob, Keep3rBondedJob, OnlyEOA {\n  // internals\n  function _isValidKeeper(address _keeper) internal override(Keep3rBondedJob, Keep3rJob) {\n    if (onlyEOA) _validateEOA(_keeper);\n    super._isValidKeeper(_keeper);\n  }\n}\n"
    },
    "solidity/contracts/for-test/PausableForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../utils/Pausable.sol';\n\ncontract PausableForTest is Pausable {\n  constructor(address _governor) Governable(_governor) {}\n\n  function testNotPaused() external notPaused {}\n}\n"
    },
    "solidity/interfaces/utils/IDustCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport './IGovernable.sol';\n\ninterface IDustCollector is IGovernable {\n  /// @notice Emitted when dust is sent\n  /// @param _to The address which wil received the funds\n  /// @param _token The token that will be transferred\n  /// @param _amount The amount of the token that will be transferred\n  event DustSent(address _token, uint256 _amount, address _to);\n\n  /// @return _ethAddress Address used to trigger a native token transfer\n  // solhint-disable-next-line func-name-mixedcase\n  function ETH_ADDRESS() external view returns (address _ethAddress);\n\n  /// @notice Allows an authorized user to transfer the tokens or eth that may have been left in a contract\n  /// @param _token The token that will be transferred\n  /// @param _amount The amont of the token that will be transferred\n  /// @param _to The address that will receive the idle funds\n  function sendDust(\n    address _token,\n    uint256 _amount,\n    address _to\n  ) external;\n}\n"
    },
    "solidity/contracts/utils/DustCollector.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9 <0.9.0;\n\nimport './Governable.sol';\nimport '../../interfaces/utils/IDustCollector.sol';\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol';\n\nabstract contract DustCollector is IDustCollector, Governable {\n  using SafeERC20 for IERC20;\n\n  /// @inheritdoc IDustCollector\n  address public constant ETH_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\n  // methods\n\n  /// @inheritdoc IDustCollector\n  function sendDust(\n    address _token,\n    uint256 _amount,\n    address _to\n  ) external onlyGovernor {\n    if (_to == address(0)) revert ZeroAddress();\n    if (_token == ETH_ADDRESS) {\n      payable(_to).transfer(_amount);\n    } else {\n      IERC20(_token).safeTransfer(_to, _amount);\n    }\n    emit DustSent(_token, _amount, _to);\n  }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "solidity/interfaces/external/IPairManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.0 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\n/// @title  Pair Manager interface\n/// @notice Generic interface for Keep3r liquidity pools (kLP)\ninterface IPairManager is IERC20Metadata {\n  /// @notice Address of the pool from which the Keep3r pair manager will interact with\n  /// @return _pool The pool's address\n  function pool() external view returns (address _pool);\n\n  /// @notice Token0 of the pool\n  /// @return _token0 The address of token0\n  function token0() external view returns (address _token0);\n\n  /// @notice Token1 of the pool\n  /// @return _token1 The address of token1\n  function token1() external view returns (address _token1);\n}\n"
    },
    "solidity/interfaces/external/IKeep3rV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\nimport '@openzeppelin/contracts/token/ERC20/IERC20.sol';\nimport '@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol';\n\nimport './IKeep3rV1Helper.sol';\n\n// solhint-disable func-name-mixedcase\ninterface IKeep3rV1 is IERC20, IERC20Metadata {\n  // Structs\n  struct Checkpoint {\n    uint32 fromBlock;\n    uint256 votes;\n  }\n\n  // Events\n  event DelegateChanged(address indexed _delegator, address indexed _fromDelegate, address indexed _toDelegate);\n  event DelegateVotesChanged(address indexed _delegate, uint256 _previousBalance, uint256 _newBalance);\n  event SubmitJob(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _block, uint256 _credit);\n  event ApplyCredit(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _block, uint256 _credit);\n  event RemoveJob(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _block, uint256 _credit);\n  event UnbondJob(address indexed _job, address indexed _liquidity, address indexed _provider, uint256 _block, uint256 _credit);\n  event JobAdded(address indexed _job, uint256 _block, address _governance);\n  event JobRemoved(address indexed _job, uint256 _block, address _governance);\n  event KeeperWorked(address indexed _credit, address indexed _job, address indexed _keeper, uint256 _block, uint256 _amount);\n  event KeeperBonding(address indexed _keeper, uint256 _block, uint256 _active, uint256 _bond);\n  event KeeperBonded(address indexed _keeper, uint256 _block, uint256 _activated, uint256 _bond);\n  event KeeperUnbonding(address indexed _keeper, uint256 _block, uint256 _deactive, uint256 _bond);\n  event KeeperUnbound(address indexed _keeper, uint256 _block, uint256 _deactivated, uint256 _bond);\n  event KeeperSlashed(address indexed _keeper, address indexed _slasher, uint256 _block, uint256 _slash);\n  event KeeperDispute(address indexed _keeper, uint256 _block);\n  event KeeperResolved(address indexed _keeper, uint256 _block);\n  event TokenCreditAddition(address indexed _credit, address indexed _job, address indexed _creditor, uint256 _block, uint256 _amount);\n\n  // Variables\n  function KPRH() external view returns (IKeep3rV1Helper);\n\n  function delegates(address _delegator) external view returns (address);\n\n  function checkpoints(address _account, uint32 _checkpoint) external view returns (Checkpoint memory);\n\n  function numCheckpoints(address _account) external view returns (uint32);\n\n  function DOMAIN_TYPEHASH() external returns (bytes32);\n\n  function DOMAINSEPARATOR() external returns (bytes32);\n\n  function DELEGATION_TYPEHASH() external returns (bytes32);\n\n  function PERMIT_TYPEHASH() external returns (bytes32);\n\n  function nonces(address _user) external view returns (uint256);\n\n  function BOND() external returns (uint256);\n\n  function UNBOND() external returns (uint256);\n\n  function LIQUIDITYBOND() external returns (uint256);\n\n  function FEE() external returns (uint256);\n\n  function BASE() external returns (uint256);\n\n  function ETH() external returns (address);\n\n  function bondings(address _user, address _bonding) external view returns (uint256);\n\n  function canWithdrawAfter(address _user, address _bonding) external view returns (uint256);\n\n  function pendingUnbonds(address _keeper, address _bonding) external view returns (uint256);\n\n  function pendingbonds(address _keeper, address _bonding) external view returns (uint256);\n\n  function bonds(address _keeper, address _bonding) external view returns (uint256);\n\n  function votes(address _delegator) external view returns (uint256);\n\n  function firstSeen(address _keeper) external view returns (uint256);\n\n  function disputes(address _keeper) external view returns (bool);\n\n  function lastJob(address _keeper) external view returns (uint256);\n\n  function workCompleted(address _keeper) external view returns (uint256);\n\n  function jobs(address _job) external view returns (bool);\n\n  function credits(address _job, address _credit) external view returns (uint256);\n\n  function liquidityProvided(\n    address _provider,\n    address _liquidity,\n    address _job\n  ) external view returns (uint256);\n\n  function liquidityUnbonding(\n    address _provider,\n    address _liquidity,\n    address _job\n  ) external view returns (uint256);\n\n  function liquidityAmountsUnbonding(\n    address _provider,\n    address _liquidity,\n    address _job\n  ) external view returns (uint256);\n\n  function jobProposalDelay(address _job) external view returns (uint256);\n\n  function liquidityApplied(\n    address _provider,\n    address _liquidity,\n    address _job\n  ) external view returns (uint256);\n\n  function liquidityAmount(\n    address _provider,\n    address _liquidity,\n    address _job\n  ) external view returns (uint256);\n\n  function keepers(address _keeper) external view returns (bool);\n\n  function blacklist(address _keeper) external view returns (bool);\n\n  function keeperList(uint256 _index) external view returns (address);\n\n  function jobList(uint256 _index) external view returns (address);\n\n  function governance() external returns (address);\n\n  function pendingGovernance() external returns (address);\n\n  function liquidityAccepted(address _liquidity) external view returns (bool);\n\n  function liquidityPairs(uint256 _index) external view returns (address);\n\n  // Methods\n  function getCurrentVotes(address _account) external view returns (uint256);\n\n  function addCreditETH(address _job) external payable;\n\n  function addCredit(\n    address _credit,\n    address _job,\n    uint256 _amount\n  ) external;\n\n  function addVotes(address _voter, uint256 _amount) external;\n\n  function removeVotes(address _voter, uint256 _amount) external;\n\n  function addKPRCredit(address _job, uint256 _amount) external;\n\n  function approveLiquidity(address _liquidity) external;\n\n  function revokeLiquidity(address _liquidity) external;\n\n  function pairs() external view returns (address[] memory);\n\n  function addLiquidityToJob(\n    address _liquidity,\n    address _job,\n    uint256 _amount\n  ) external;\n\n  function applyCreditToJob(\n    address _provider,\n    address _liquidity,\n    address _job\n  ) external;\n\n  function unbondLiquidityFromJob(\n    address _liquidity,\n    address _job,\n    uint256 _amount\n  ) external;\n\n  function removeLiquidityFromJob(address _liquidity, address _job) external;\n\n  function mint(uint256 _amount) external;\n\n  function burn(uint256 _amount) external;\n\n  function worked(address _keeper) external;\n\n  function receipt(\n    address _credit,\n    address _keeper,\n    uint256 _amount\n  ) external;\n\n  function workReceipt(address _keeper, uint256 _amount) external;\n\n  function receiptETH(address _keeper, uint256 _amount) external;\n\n  function addJob(address _job) external;\n\n  function getJobs() external view returns (address[] memory);\n\n  function removeJob(address _job) external;\n\n  function setKeep3rHelper(address _keep3rHelper) external;\n\n  function setGovernance(address _governance) external;\n\n  function acceptGovernance() external;\n\n  function isKeeper(address _keeper) external returns (bool);\n\n  function isMinKeeper(\n    address _keeper,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) external returns (bool);\n\n  function isBondedKeeper(\n    address _keeper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age\n  ) external returns (bool);\n\n  function bond(address _bonding, uint256 _amount) external;\n\n  function getKeepers() external view returns (address[] memory);\n\n  function activate(address _bonding) external;\n\n  function unbond(address _bonding, uint256 _amount) external;\n\n  function slash(\n    address _bonded,\n    address _keeper,\n    uint256 _amount\n  ) external;\n\n  function withdraw(address _bonding) external;\n\n  function dispute(address _keeper) external;\n\n  function revoke(address _keeper) external;\n\n  function resolve(address _keeper) external;\n\n  function permit(\n    address _owner,\n    address _spender,\n    uint256 _amount,\n    uint256 _deadline,\n    uint8 _v,\n    bytes32 _r,\n    bytes32 _s\n  ) external;\n}\n"
    },
    "solidity/interfaces/external/IKeep3rV1Helper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <0.9.0;\n\ninterface IKeep3rV1Helper {\n  function quote(uint256 _eth) external view returns (uint256);\n\n  function getFastGas() external view returns (uint256);\n\n  function bonds(address _keeper) external view returns (uint256);\n\n  function getQuoteLimit(uint256 _gasUsed) external view returns (uint256);\n\n  function getQuoteLimitFor(address _origin, uint256 _gasUsed) external view returns (uint256);\n}\n"
    },
    "solidity/contracts/for-test/DustCollectorForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../../contracts/utils/DustCollector.sol';\n\ncontract DustCollectorForTest is DustCollector {\n  constructor() DustCollector() Governable(msg.sender) {}\n}\n"
    },
    "solidity/contracts/for-test/Keep3rBondedJobForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../utils/Keep3rBondedJob.sol';\n\ncontract Keep3rBondedJobForTest is Keep3rBondedJob {\n  constructor(address _governor) Governable(_governor) Keep3rJob() {}\n}\n"
    },
    "solidity/contracts/for-test/Keep3rJobForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../utils/Keep3rJob.sol';\n\ncontract Keep3rJobForTest is Keep3rJob {\n  constructor(address _governor) Governable(_governor) Keep3rJob() {}\n\n  function externalIsValidKeeper(address _keeper) external {\n    _isValidKeeper(_keeper);\n  }\n}\n"
    },
    "solidity/contracts/for-test/Keep3rMeteredJobForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../utils/Keep3rMeteredJob.sol';\n\ncontract Keep3rMeteredJobForTest is Keep3rMeteredJob {\n  constructor(address _governance) Governable(_governance) {}\n\n  function internalCalculateCredits(uint256 _gasUsed) external view returns (uint256 _credits) {\n    return _calculateCredits(_gasUsed);\n  }\n}\n"
    },
    "solidity/contracts/for-test/GovernableForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../utils/Governable.sol';\n\ncontract GovernableForTest is Governable {\n  constructor(address _governor) Governable(_governor) {}\n}\n"
    },
    "solidity/contracts/for-test/TendV2Keep3rJobForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../TendV2Keep3rJob.sol';\n\ncontract TendV2Keep3rJobForTest is TendV2Keep3rJob {\n  constructor(\n    address _governor,\n    address _mechanicsRegistry,\n    address _v2Keeper,\n    uint256 _workCooldown,\n    address _keep3r,\n    address _keep3rHelper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age,\n    bool _onlyEOA\n  ) TendV2Keep3rJob(_governor, _mechanicsRegistry, _v2Keeper, _workCooldown, _keep3r, _keep3rHelper, _bond, _minBond, _earned, _age, _onlyEOA) {}\n\n  uint256 internal _baseFee;\n\n  function _gasPrice() internal view virtual override returns (uint256) {\n    return _baseFee;\n  }\n}\n"
    },
    "solidity/contracts/for-test/HarvestV2Keep3rStealthJobForTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.8.9 <0.9.0;\n\nimport '../HarvestV2Keep3rStealthJob.sol';\n\ncontract HarvestV2Keep3rStealthJobForTest is HarvestV2Keep3rStealthJob {\n  constructor(\n    address _governor,\n    address _mechanicsRegistry,\n    address _stealthRelayer,\n    address _v2Keeper,\n    uint256 _workCooldown,\n    address _keep3r,\n    address _keep3rHelper,\n    address _bond,\n    uint256 _minBond,\n    uint256 _earned,\n    uint256 _age,\n    bool _onlyEOA\n  )\n    HarvestV2Keep3rStealthJob(\n      _governor,\n      _mechanicsRegistry,\n      _stealthRelayer,\n      _v2Keeper,\n      _workCooldown,\n      _keep3r,\n      _keep3rHelper,\n      _bond,\n      _minBond,\n      _earned,\n      _age,\n      _onlyEOA\n    )\n  {}\n\n  uint256 internal _baseFee;\n\n  function _gasPrice() internal view virtual override returns (uint256) {\n    return _baseFee;\n  }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    },
    "libraries": {
      "": {
        "__CACHE_BREAKER__": "0x00000000d41867734bbee4c6863d9255b2b06ac1"
      }
    }
  }
}